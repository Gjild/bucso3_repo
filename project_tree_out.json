{
  "type": "directory",
  "name": "bucso3_repo",
  "path": ".",
  "children": [
    {
      "type": "directory",
      "name": "configs",
      "path": "configs",
      "children": [
        {
          "type": "file",
          "name": "KaBUC_LTC5553_ADMV1550_planner.yaml",
          "path": "configs\\KaBUC_LTC5553_ADMV1550_planner.yaml",
          "size": 15975,
          "content_truncated": false,
          "contents": "description: \"Ka-band dual-conversion BUC planner for LTC5553 + ADMV1550 (converted from KaBUC_LTC5553_ADMV1550 config)\"\r\n\r\n# -------------------------------------------------------------------\r\n#  System bands & RF configurations\r\n# -------------------------------------------------------------------\r\n\r\nif1_band:\r\n  start: 950.0e6\r\n  stop: 2450.0e6\r\n\r\nrf_band:\r\n  start: 27.5e9\r\n  stop: 31.0e9\r\n\r\n# Each RF configuration uses the full IF1 band (1.5 GHz).\r\n# Two overlapping 1.5 GHz RF channels covering 27.5–31 GHz.\r\n# if1_subband: omitted => use global IF1 band\r\nrf_configurations:\r\n  - config_id: \"rf_28.25GHz\"\r\n    rf_center: 28.25e9        # 27.5–29.0 GHz\r\n    rf_bandwidth: 1.5e9\r\n\r\n  - config_id: \"rf_29.25GHz\"\r\n    rf_center: 29.25e9        # 28.5–30 GHz\r\n    rf_bandwidth: 1.5e9\r\n    \r\n  - config_id: \"rf_30.25GHz\"\r\n    rf_center: 30.25e9        # 29.5–31 GHz\r\n    rf_bandwidth: 1.5e9\r\n\r\n# Enforce non-inverting IF1 -> RF mapping for desired path\r\nnon_inverting_mapping_required: true\r\n\r\n# -------------------------------------------------------------------\r\n#  Mixer 1: LTC5553 (IF1 -> IF2)\r\n# -------------------------------------------------------------------\r\n\r\nmixer1:\r\n  name: \"LTC5553_MXR1\"\r\n\r\n  # Spur envelope: we only use the explicit table below and ignore\r\n  # (m, n) outside it (no default floor applied).\r\n  spur_envelope:\r\n    m_max: 4\r\n    n_max: 4\r\n    enforce_envelope_completeness: false\r\n    unspecified_floor_dbc: null\r\n\r\n  # Valid operating ranges\r\n  ranges:\r\n    # IF port (IF1 side): LTC5553 IF range ≈ 0.5–9 GHz\r\n    if_range:\r\n      start: 500e6\r\n      stop: 9.0e9\r\n\r\n    # LO port (LO1): constrained to 3–15 GHz usable region\r\n    lo_range:\r\n      start: 3.0e9\r\n      stop: 15.0e9\r\n\r\n    # RF port (IF2 node): planning range matching IF2 model\r\n    rf_range:\r\n      start: 4.0e9\r\n      stop: 20.0e9\r\n\r\n  # Isolation terms, relative to desired Mixer1 output\r\n  isolation:\r\n    lo_to_rf_dbc: -25.0\r\n    if_to_rf_dbc: -40.0\r\n\r\n  # Desired fundamental: m=+1, n=1 (LO1 + IF1)\r\n  desired_m: 1\r\n  desired_n: 1\r\n\r\n  # Spur table from LTC5553 spur_list.\r\n  # All entries are referenced to the desired Mixer1 product and are\r\n  # assumed valid over the full mixer ranges above.\r\n  spur_table:\r\n    # m = 0 row\r\n    - m: 0\r\n      n: 1\r\n      level_dbc: -51.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 0\r\n      n: 2\r\n      level_dbc: -58.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 0\r\n      n: 3\r\n      level_dbc: -75.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 0\r\n      n: 4\r\n      level_dbc: -75.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n\r\n    # m = 1 row (skip [1,1] desired fundamental)\r\n    - m: 1\r\n      n: 0\r\n      level_dbc: -24.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 1\r\n      n: 2\r\n      level_dbc: -64.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 1\r\n      n: 3\r\n      level_dbc: -72.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 1\r\n      n: 4\r\n      level_dbc: -75.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n\r\n    # m = 2 row\r\n    - m: 2\r\n      n: 0\r\n      level_dbc: -15.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 2\r\n      n: 1\r\n      level_dbc: -42.0   # CRITICAL VALUE\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 2\r\n      n: 2\r\n      level_dbc: -58.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 2\r\n      n: 3\r\n      level_dbc: -72.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 2\r\n      n: 4\r\n      level_dbc: -73.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n\r\n    # m = 3 row\r\n    - m: 3\r\n      n: 0\r\n      level_dbc: -16.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 3\r\n      n: 1\r\n      level_dbc: -13.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 3\r\n      n: 2\r\n      level_dbc: -61.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 3\r\n      n: 3\r\n      level_dbc: -71.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 3\r\n      n: 4\r\n      level_dbc: -73.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n\r\n    # m = 4 row\r\n    - m: 4\r\n      n: 0\r\n      level_dbc: -20.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 4\r\n      n: 1\r\n      level_dbc: -53.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 4\r\n      n: 2\r\n      level_dbc: -62.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 4\r\n      n: 3\r\n      level_dbc: -75.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n    - m: 4\r\n      n: 4\r\n      level_dbc: -75.0\r\n      if_range: {start: 0.5e9, stop: 9.0e9}\r\n      lo_range: {start: 3.0e9, stop: 15.0e9}\r\n      rf_range: {start: 4.0e9, stop: 20.0e9}\r\n\r\n# -------------------------------------------------------------------\r\n#  Mixer 2: ADMV1550 (IF2 -> RF)\r\n# -------------------------------------------------------------------\r\n\r\nmixer2:\r\n  name: \"ADMV1550_MXR2\"\r\n\r\n  spur_envelope:\r\n    m_max: 4\r\n    n_max: 4\r\n    enforce_envelope_completeness: false\r\n    unspecified_floor_dbc: null\r\n\r\n  ranges:\r\n    # IF port (IF2): ADMV IF 0–20 GHz\r\n    if_range:\r\n      start: 0.0\r\n      stop: 20.0e9\r\n\r\n    # LO port (LO2)\r\n    lo_range:\r\n      start: 15.0e9\r\n      stop: 32.0e9\r\n\r\n    # RF output: cover Ka band + nearby spur region\r\n    rf_range:\r\n      start: 20.0e9\r\n      stop: 50.0e9\r\n\r\n  isolation:\r\n    lo_to_rf_dbc: -35.0\r\n    if_to_rf_dbc: -45.0\r\n\r\n  desired_m: 1\r\n  desired_n: 1\r\n\r\n  spur_table:\r\n    # m = 0 row\r\n    - m: 0\r\n      n: 1\r\n      level_dbc: -55.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 0\r\n      n: 2\r\n      level_dbc: -89.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 0\r\n      n: 3\r\n      level_dbc: -89.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 0\r\n      n: 4\r\n      level_dbc: -87.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n\r\n    # m = 1 row (skip [1,1] desired fundamental)\r\n    - m: 1\r\n      n: 0\r\n      level_dbc: -5.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 1\r\n      n: 2\r\n      level_dbc: -46.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 1\r\n      n: 3\r\n      level_dbc: -73.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 1\r\n      n: 4\r\n      level_dbc: -74.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n\r\n    # m = 2 row\r\n    - m: 2\r\n      n: 0\r\n      level_dbc: -3.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 2\r\n      n: 1\r\n      level_dbc: -41.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 2\r\n      n: 2\r\n      level_dbc: -61.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 2\r\n      n: 3\r\n      level_dbc: -63.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 2\r\n      n: 4\r\n      level_dbc: -60.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n\r\n    # m = 3 row\r\n    - m: 3\r\n      n: 0\r\n      level_dbc: -3.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 3\r\n      n: 1\r\n      level_dbc: -11.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 3\r\n      n: 2\r\n      level_dbc: -50.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 3\r\n      n: 3\r\n      level_dbc: -65.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 3\r\n      n: 4\r\n      level_dbc: -65.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n\r\n    # m = 4 row\r\n    - m: 4\r\n      n: 0\r\n      level_dbc: -3.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 4\r\n      n: 1\r\n      level_dbc: -11.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 4\r\n      n: 2\r\n      level_dbc: -51.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 4\r\n      n: 3\r\n      level_dbc: -65.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n    - m: 4\r\n      n: 4\r\n      level_dbc: -65.0\r\n      if_range: {start: 0.0, stop: 20.0e9}\r\n      lo_range: {start: 15.0e9, stop: 32.0e9}\r\n      rf_range: {start: 20.0e9, stop: 50.0e9}\r\n\r\n# -------------------------------------------------------------------\r\n#  LO Synthesizers (simplified from legacy LO models)\r\n# -------------------------------------------------------------------\r\n\r\nlo1:\r\n  name: \"LMX2594_LO1\"\r\n  # Restrict to practical band used with Mixer1\r\n  freq_range:\r\n    start: 3.0e9\r\n    stop: 15.0e9\r\n  # Grid step: coarser than legacy 1 kHz to avoid 20k-point truncation\r\n  grid_step: 1.0e6   # 1 MHz resolution\r\n\r\n  # Single nominal PFD for PLL spur modelling\r\n  pfd_frequency: 100.0e6\r\n\r\n  # Harmonics from legacy config (mode 'fracN')\r\n  harmonics:\r\n    - order: 2\r\n      level_dbc: -20.0\r\n    - order: 3\r\n      level_dbc: -30.0\r\n\r\n  # Simple PLL spur model derived from legacy pfd_spurs_at_output\r\n  pll_spurs:\r\n    - offset_multiple: 1\r\n      level_dbc: -90.0\r\n    - offset_multiple: 2\r\n      level_dbc: -90.0\r\n\r\nlo2:\r\n  name: \"ADF4371_LO2\"\r\n  freq_range:\r\n    start: 15.0e9\r\n    stop: 32.0e9\r\n  grid_step: 1.0e6   # 1 MHz resolution\r\n\r\n  pfd_frequency: 125.0e6\r\n\r\n  harmonics:\r\n    - order: 2\r\n      level_dbc: -30.0\r\n    - order: 3\r\n      level_dbc: -30.0\r\n\r\n  pll_spurs:\r\n    - offset_multiple: 1\r\n      level_dbc: -90.0\r\n    - offset_multiple: 2\r\n      level_dbc: -90.0\r\n\r\n# -------------------------------------------------------------------\r\n#  IF2 & RF Filters\r\n# -------------------------------------------------------------------\r\n\r\nfilters:\r\n  if2_constraints:\r\n    # Let the optimizer pick between 1..4 IF2 filters\r\n    min_filters: 1\r\n    max_filters: 4\r\n\r\n    # IF2 center-frequency range from legacy if2_model.center_range_hz\r\n    fc_range:\r\n      start: 4.0e9\r\n      stop: 20.0e9\r\n\r\n    # IF2 BW range from legacy if2_model min/max_bw_hz\r\n    bw_range:\r\n      start: 1.5e9\r\n      stop: 2.0e9\r\n\r\n    # Slope range (dB/decade). Legacy rolloff was 100 dB/dec.\r\n    # Allow a reasonably steep negative range.\r\n    slope_range: [-200.0, -20.0]\r\n\r\n    # Feasibility margin around desired IF2 band (Hz)\r\n    feasibility_margin_hz: 50.0e6\r\n\r\n  # Legacy RF filter CSV\r\n  rf_bpf_csv_path: \"configs\\\\RF_S21_28to31GHz.csv\"\r\n\r\n# -------------------------------------------------------------------\r\n#  Spur limits & masks\r\n# -------------------------------------------------------------------\r\n\r\nspur_limits:\r\n  # From masks.inband / masks.outofband default_dbc\r\n  in_band_limit_dbc: -60.0\r\n  out_of_band_limit_dbc: -60.0\r\n\r\n  # No frequency-dependent spur mask in the legacy config\r\n  mask: null\r\n\r\n  # Evaluate out-of-band spurs over DC–50 GHz\r\n  out_of_band_range:\r\n    start: 0.0\r\n    stop: 50.0e9\r\n\r\n  # For a wideband spur vs. mask we use mask at center frequency\r\n  mask_eval_mode: \"center\"\r\n\r\n# -------------------------------------------------------------------\r\n#  Grids & performance knobs\r\n# -------------------------------------------------------------------\r\n\r\ngrids:\r\n  # IF1 sweep grid over 950–2450 MHz (from legacy if1_center_step_hz)\r\n  if1_grid_step_hz: 50.0e6\r\n\r\n  # Spur integration step (RBW-ish) – coarser than 500 kHz for speed\r\n  spur_integration_step_hz: 5.0e6\r\n\r\n  # IF1 harmonics: use up to 3rd (legacy if1_model)\r\n  max_if1_harmonic_order: 3\r\n\r\n  # Ignore spurs below this level at early stages\r\n  min_spur_level_considered_dbc: -100.0\r\n\r\n  # Limit LO1/LO2 candidates per RF config (coarse enumeration)\r\n  max_lo_candidates_per_rf: 50\r\n\r\n  # Limit IF2 bank candidates per filter-count during search\r\n  max_if2_bank_candidates: 50\r\n\r\n  # Coarse-pruning: LO plans whose coarse spur margin << 0 dB get dropped\r\n  coarse_spur_margin_min_db: -10.0\r\n\r\n  # Mixer2 spur generation focus around desired IF2 band (0 => off)\r\n  mixer2_if2_focus_margin_hz: 0.0\r\n\r\n  # Parallel execution & Numba\r\n  parallel: true\r\n  use_numba: false\r\n\r\n  # Ensure we keep at least this many LO candidates after coarse pruning\r\n  min_lo_candidates_per_rf_after_coarse: 2\r\n\r\n# -------------------------------------------------------------------\r\n#  IF1 harmonics (integrated levels vs IF1 fundamental)\r\n# -------------------------------------------------------------------\r\n\r\n# From legacy if1_model.harmonics (k=2 at -30 dBc, k=3 at -40 dBc).\r\n# Fundamental (k=1) is implicitly 0 dBc in this tool.\r\nif1_harmonics_dbc:\r\n  \"2\": -30.0\r\n  \"3\": -40.0\r\n",
          "encoding": "utf-8",
          "encoding_error": false
        },
        {
          "type": "file",
          "name": "RF_S21_28to31GHz.csv",
          "path": "configs\\RF_S21_28to31GHz.csv",
          "size": 1745,
          "content_truncated": false,
          "contents": "freq,attenuation_db\r\n23.4e+9,80.0\r\n23.5e+9,57.7\r\n23.6e+9,54.3\r\n23.7e+9,52.6\r\n23.8e+9,53.3\r\n23.9e+9,51.3\r\n24.0e+9,49.6\r\n24.1e+9,49.6\r\n24.2e+9,51.6\r\n24.3e+9,51.6\r\n24.4e+9,50.3\r\n24.5e+9,54.1\r\n24.6e+9,52.0\r\n24.7e+9,50.6\r\n24.8e+9,50.0\r\n24.9e+9,51.3\r\n25.0e+9,51.0\r\n25.1e+9,50.6\r\n25.2e+9,48.3\r\n25.3e+9,47.0\r\n25.4e+9,46.1\r\n25.5e+9,44.5\r\n25.6e+9,43.6\r\n25.7e+9,42.7\r\n25.8e+9,41.0\r\n25.9e+9,38.3\r\n26.0e+9,35.6\r\n26.1e+9,32.6\r\n26.2e+9,29.8\r\n26.3e+9,27.1\r\n26.4e+9,23.5\r\n26.5e+9,19.9\r\n26.6e+9,16.2\r\n26.7e+9,12.4\r\n26.8e+9,8.4\r\n26.9e+9,4.7\r\n27.0e+9,2.6\r\n27.1e+9,1.5\r\n27.2e+9,1.3\r\n27.3e+9,1.1\r\n27.4e+9,1.0\r\n27.5e+9,0.9\r\n27.6e+9,0.8\r\n27.7e+9,0.8\r\n27.8e+9,0.8\r\n27.9e+9,0.8\r\n28.0e+9,0.8\r\n28.1e+9,0.7\r\n28.2e+9,0.7\r\n28.3e+9,0.7\r\n28.4e+9,0.7\r\n28.5e+9,0.7\r\n28.6e+9,0.7\r\n28.7e+9,0.7\r\n28.8e+9,0.5\r\n28.9e+9,0.5\r\n29.0e+9,0.5\r\n29.1e+9,0.5\r\n29.2e+9,0.7\r\n29.3e+9,0.7\r\n29.4e+9,0.7\r\n29.5e+9,0.7\r\n29.6e+9,0.7\r\n29.7e+9,0.7\r\n29.8e+9,0.7\r\n29.9e+9,0.7\r\n30.0e+9,0.7\r\n30.1e+9,0.7\r\n30.2e+9,0.7\r\n30.3e+9,0.7\r\n30.4e+9,0.7\r\n30.5e+9,0.7\r\n30.6e+9,0.8\r\n30.7e+9,0.7\r\n30.8e+9,0.7\r\n30.9e+9,0.8\r\n31.0e+9,0.8\r\n31.1e+9,0.8\r\n31.2e+9,0.9\r\n31.3e+9,1.0\r\n31.4e+9,1.2\r\n31.5e+9,1.3\r\n31.6e+9,1.6\r\n31.7e+9,2.4\r\n31.8e+9,4.4\r\n31.9e+9,7.2\r\n32.0e+9,10.6\r\n32.1e+9,13.8\r\n32.2e+9,17.7\r\n32.3e+9,20.3\r\n32.4e+9,23.2\r\n32.5e+9,25.7\r\n32.6e+9,28.2\r\n32.7e+9,30.5\r\n32.8e+9,32.7\r\n32.9e+9,34.6\r\n33.0e+9,36.1\r\n33.1e+9,38.0\r\n33.2e+9,39.2\r\n33.3e+9,40.7\r\n33.4e+9,41.9\r\n33.5e+9,43.4\r\n33.6e+9,45.1\r\n33.7e+9,46.2\r\n33.8e+9,47.1\r\n33.9e+9,47.6\r\n34.0e+9,49.4\r\n34.1e+9,50.2\r\n34.2e+9,52.4\r\n34.3e+9,52.2\r\n34.4e+9,50.9\r\n34.5e+9,53.6\r\n34.6e+9,52.6\r\n34.7e+9,52.4\r\n34.8e+9,52.1\r\n34.9e+9,52.0\r\n35.0e+9,51.6\r\n35.1e+9,50.3\r\n35.2e+9,49.7\r\n35.3e+9,49.9\r\n35.4e+9,50.5\r\n35.5e+9,50.4\r\n35.6e+9,51.2\r\n35.7e+9,49.1\r\n35.8e+9,48.4\r\n35.9e+9,47.8\r\n36.0e+9,80.0",
          "encoding": "utf-8",
          "encoding_error": false
        }
      ]
    },
    {
      "type": "directory",
      "name": "src",
      "path": "src",
      "children": [
        {
          "type": "directory",
          "name": "buc_planner",
          "path": "src\\buc_planner",
          "children": [
            {
              "type": "file",
              "name": "__init__.py",
              "path": "src\\buc_planner\\__init__.py",
              "size": 576,
              "content_truncated": false,
              "contents": "# src/buc_planner/__init__.py\r\n\"\"\"\r\nDual-Conversion BUC Frequency Planning & Spur-Analysis Tool.\r\n\r\nThis package provides a planning-grade estimator for LO planning, IF2 filter bank\r\ndesign, and spur analysis in a dual-conversion block-up converter:\r\n\r\n    IF1 -> Mixer1 -> IF2 BPF Bank (parallel, switched) -> Mixer2 -> RF BPF -> RF Out\r\n\"\"\"\r\n\r\nfrom .config_models import (\r\n    SystemConfig,\r\n    load_config,\r\n)\r\n\r\nfrom .optimizer import (\r\n    Planner,\r\n    PlannerResult,\r\n)\r\n\r\n__all__ = [\r\n    \"SystemConfig\",\r\n    \"load_config\",\r\n    \"Planner\",\r\n    \"PlannerResult\",\r\n]",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "cli.py",
              "path": "src\\buc_planner\\cli.py",
              "size": 2337,
              "content_truncated": false,
              "contents": "# src/buc_planner/cli.py\r\nfrom __future__ import annotations\r\n\r\nimport argparse\r\nfrom pathlib import Path\r\nimport numpy as np\r\n\r\nfrom .config_models import load_config\r\nfrom .optimizer import Planner\r\nfrom .outputs import (\r\n    write_lo_plan_policy,\r\n    write_spur_ledger,\r\n    write_if2_bank_description,\r\n    write_run_metadata,\r\n)\r\nfrom .plotting import plot_if2_bank\r\n\r\n\r\ndef main(argv=None) -> None:\r\n    parser = argparse.ArgumentParser(\r\n        description=\"Dual-Conversion BUC Frequency Planner & Spur Analyzer\"\r\n    )\r\n    parser.add_argument(\"config\", type=str, help=\"Path to YAML/JSON config file\")\r\n    parser.add_argument(\r\n        \"--out-dir\",\r\n        type=str,\r\n        default=\"buc_planner_out\",\r\n        help=\"Output directory\",\r\n    )\r\n    parser.add_argument(\r\n        \"--no-plots\",\r\n        action=\"store_true\",\r\n        help=\"Disable IF2 bank plot generation\",\r\n    )\r\n    args = parser.parse_args(argv)\r\n\r\n    cfg = load_config(args.config)\r\n    planner = Planner(cfg)\r\n    result = planner.run()\r\n\r\n    out_dir = Path(args.out_dir)\r\n    out_dir.mkdir(parents=True, exist_ok=True)\r\n\r\n    # LO plan policy\r\n    write_lo_plan_policy(\r\n        out_dir / \"lo_plan_policy.jsonl\",\r\n        cfg,\r\n        result.lo_plans,\r\n        result.if2_bank_design,\r\n        result.summaries,\r\n    )\r\n\r\n    # Spur ledger\r\n    write_spur_ledger(\r\n        out_dir / \"spur_ledger.jsonl\",\r\n        result.spur_results,\r\n        top_n_per_config=50,\r\n    )\r\n\r\n    # IF2 bank description & CSVs\r\n    if2_json = out_dir / \"if2_bank.json\"\r\n    if2_csv_dir = out_dir / \"if2_filters\"\r\n    # freq range for plotting CSVs (use mixer2 IF range as reference)\r\n    freq_min = cfg.mixer2.ranges.if_range.start\r\n    freq_max = cfg.mixer2.ranges.if_range.stop\r\n    write_if2_bank_description(\r\n        if2_json,\r\n        if2_csv_dir,\r\n        result.if2_bank_design,\r\n        freq_min=freq_min,\r\n        freq_max=freq_max,\r\n    )\r\n\r\n    if not args.no_plots:\r\n        plot_if2_bank(\r\n            result.if2_bank_design.bank,\r\n            cfg.mixer2.ranges.if_range,\r\n            out_path=out_dir / \"if2_bank.png\",\r\n            lo_plans=result.lo_plans,\r\n        )\r\n\r\n    # Run metadata\r\n    write_run_metadata(\r\n        out_dir / \"run_metadata.json\",\r\n        cfg,\r\n        result.spur_results,\r\n    )\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "config_models.py",
              "path": "src\\buc_planner\\config_models.py",
              "size": 14064,
              "content_truncated": false,
              "contents": "# src/buc_planner/config_models.py\r\nfrom __future__ import annotations\r\n\r\nimport json\r\nfrom dataclasses import dataclass, field\r\nfrom pathlib import Path\r\nfrom typing import List, Optional, Tuple, Dict, Literal, Union\r\nimport warnings\r\n\r\nimport yaml  # planning-grade: assume PyYAML available\r\nimport re\r\n\r\n\r\nFreq = float  # Hz (or consistent unit across config)\r\ndB = float\r\ndBc = float\r\n\r\n_NUMERIC_SCALAR_RE = re.compile(\r\n    r'^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$'\r\n)\r\n\r\ndef _coerce_numeric_scalars(obj):\r\n    \"\"\"\r\n    Recursively walk a YAML-loaded structure and convert\r\n    numeric-looking strings (incl. 0.5e9, 950.0e6) to floats.\r\n\r\n    Dict *keys* are left untouched; only values are coerced.\r\n    \"\"\"\r\n    if isinstance(obj, dict):\r\n        return {k: _coerce_numeric_scalars(v) for k, v in obj.items()}\r\n    elif isinstance(obj, list):\r\n        return [_coerce_numeric_scalars(v) for v in obj]\r\n    elif isinstance(obj, str):\r\n        s = obj.strip()\r\n        if _NUMERIC_SCALAR_RE.match(s):\r\n            try:\r\n                return float(s)\r\n            except ValueError:\r\n                return obj\r\n        return obj\r\n    else:\r\n        return obj\r\n\r\n@dataclass\r\nclass Range:\r\n    \"\"\"Closed interval [start, stop]. Units consistent with Freq.\"\"\"\r\n    start: Freq\r\n    stop: Freq\r\n    \r\n    def __post_init__(self):\r\n        # Coerce to float in case YAML gave us strings\r\n        self.start = float(self.start)\r\n        self.stop = float(self.stop)\r\n\r\n    def contains(self, f: Freq) -> bool:\r\n        return self.start <= f <= self.stop\r\n\r\n    def intersect(self, other: \"Range\") -> Optional[\"Range\"]:\r\n        lo = max(self.start, other.start)\r\n        hi = min(self.stop, other.stop)\r\n        if lo <= hi:\r\n            return Range(lo, hi)\r\n        return None\r\n\r\n    @property\r\n    def width(self) -> float:\r\n        return self.stop - self.start\r\n\r\n\r\n@dataclass\r\nclass RfConfiguration:\r\n    \"\"\"Single RF configuration (e.g. RF channel / band).\"\"\"\r\n    config_id: str\r\n    rf_center: Freq\r\n    rf_bandwidth: Freq\r\n    # optional IF1 sub-band; if None, use global IF1 band\r\n    if1_subband: Optional[Range] = None\r\n\r\n\r\n@dataclass\r\nclass SpurTableEntry:\r\n    \"\"\"\r\n    Spur table entry for a mixer: f_spur = m * f_LO ± n * f_IF.\r\n\r\n    All levels are relative to the desired mixer product (fundamental) at that mixer.\r\n    \"\"\"\r\n    m: int\r\n    n: int\r\n    level_dbc: dBc\r\n    if_range: Range\r\n    lo_range: Range\r\n    rf_range: Range\r\n    lo_tone_type: Optional[str] = None  # \"fundamental\", \"harmonic_k\", \"pll_spur_N\", etc.\r\n\r\n\r\n@dataclass\r\nclass MixerSpurEnvelopePolicy:\r\n    m_max: int\r\n    n_max: int\r\n    enforce_envelope_completeness: bool = False\r\n    unspecified_floor_dbc: Optional[dBc] = None  # if None => ignore unspecified\r\n\r\n\r\n@dataclass\r\nclass MixerIsolation:\r\n    lo_to_rf_dbc: dBc\r\n    if_to_rf_dbc: dBc\r\n\r\n\r\n@dataclass\r\nclass MixerRanges:\r\n    \"\"\"\r\n    Valid operating ranges for a mixer.\r\n\r\n    Note:\r\n      * For Mixer1, rf_range represents the *output* of Mixer1, i.e. the IF2 node\r\n        (not the final RF band).\r\n      * For Mixer2, rf_range is the true RF output range.\r\n    \"\"\"\r\n    if_range: Range\r\n    lo_range: Range\r\n    rf_range: Range\r\n\r\n\r\n@dataclass\r\nclass MixerConfig:\r\n    name: str\r\n    spur_table: List[SpurTableEntry]\r\n    spur_envelope: MixerSpurEnvelopePolicy\r\n    isolation: MixerIsolation\r\n    ranges: MixerRanges\r\n    # desired fundamental mapping: e.g. (m=+1,n=1) for LO+IF or (m=-1,n=1) for LO-IF.\r\n    desired_m: int = 1\r\n    desired_n: int = 1\r\n\r\n\r\n@dataclass\r\nclass LOHarmonic:\r\n    order: int\r\n    level_dbc: dBc  # relative to fundamental LO tone\r\n\r\n\r\n@dataclass\r\nclass PLLSpur:\r\n    offset_multiple: int  # N in ±N * f_PFD\r\n    level_dbc: dBc       # relative to LO fundamental\r\n\r\n\r\n@dataclass\r\nclass LOSynthConfig:\r\n    name: str\r\n    freq_range: Range\r\n    grid_step: Freq          # LO frequency step (Hz)\r\n    pfd_frequency: Optional[Freq] = None\r\n    harmonics: List[LOHarmonic] = field(default_factory=list)\r\n    pll_spurs: List[PLLSpur] = field(default_factory=list)\r\n\r\n\r\n@dataclass\r\nclass IF2BankConstraints:\r\n    min_filters: int\r\n    max_filters: int\r\n    fc_range: Range\r\n    bw_range: Range\r\n    slope_range: Tuple[dB, dB]  # (S_min, S_max) in dB/decade (negative)\r\n    # margin for early feasibility checks (Hz)\r\n    feasibility_margin_hz: Freq = 0.0\r\n\r\n\r\n@dataclass\r\nclass RFMaskConfig:\r\n    csv_path: Optional[str] = None\r\n    apply_in_band: bool = True\r\n    apply_out_of_band: bool = True\r\n\r\n\r\n@dataclass\r\nclass SpurLimitsConfig:\r\n    in_band_limit_dbc: Optional[dBc] = None\r\n    out_of_band_limit_dbc: Optional[dBc] = None\r\n    mask: Optional[RFMaskConfig] = None\r\n    out_of_band_range: Optional[Range] = None\r\n    # How to evaluate mask vs wideband spur:\r\n    #   \"center\"      -> mask at spur center frequency (current behaviour)\r\n    #   \"worst_case\"  -> minimum allowed level over whole spur band\r\n    mask_eval_mode: str = \"center\"  # \"center\" or \"worst_case\"\r\n\r\n\r\n@dataclass\r\nclass GridsAndPerformanceConfig:\r\n    if1_grid_step_hz: Freq\r\n    spur_integration_step_hz: Freq\r\n    max_if1_harmonic_order: int\r\n    min_spur_level_considered_dbc: dBc = -120.0\r\n    max_lo_candidates_per_rf: int = 50\r\n    max_if2_bank_candidates: int = 50\r\n    coarse_spur_margin_min_db: dB = -10.0\r\n    # Optional restriction of Mixer2 spur generation to desired IF2 ± margin\r\n    mixer2_if2_focus_margin_hz: Freq = 0.0\r\n    parallel: bool = True\r\n    use_numba: bool = False  # allows toggling JIT\r\n    # minimum number of LO candidates to keep after coarse pruning.\r\n    # If coarse pruning would leave fewer than this (including zero),\r\n    # we re-inject the best candidates up to this count.\r\n    min_lo_candidates_per_rf_after_coarse: int = 1\r\n\r\n\r\n\r\n@dataclass\r\nclass FilterConfig:\r\n    if2_constraints: IF2BankConstraints\r\n    rf_bpf_csv_path: str\r\n\r\n\r\n@dataclass\r\nclass SystemConfig:\r\n    \"\"\"\r\n    Top-level configuration object for a planning run.\r\n    \"\"\"\r\n    if1_band: Range\r\n    rf_band: Range\r\n    rf_configurations: List[RfConfiguration]\r\n    non_inverting_mapping_required: bool\r\n    mixer1: MixerConfig\r\n    mixer2: MixerConfig\r\n    lo1: LOSynthConfig\r\n    lo2: LOSynthConfig\r\n    filters: FilterConfig\r\n    spur_limits: SpurLimitsConfig\r\n    grids: GridsAndPerformanceConfig\r\n\r\n    # IF1 harmonics amplitudes: order -> level_dbc (integrated)\r\n    if1_harmonics_dbc: Dict[int, dBc] = field(default_factory=dict)\r\n\r\n    # Metadata / description\r\n    description: Optional[str] = None\r\n\r\n\r\ndef _load_yaml_or_json(path: Path) -> dict:\r\n    text = path.read_text()\r\n    if path.suffix.lower() in {\".yaml\", \".yml\"}:\r\n        raw = yaml.safe_load(text)\r\n    else:\r\n        raw = json.loads(text)\r\n\r\n    # Fix PyYAML’s limited float parsing (e.g. 950.0e6 -> float)\r\n    return _coerce_numeric_scalars(raw)\r\n\r\ndef load_config(path: Union[str, Path]) -> SystemConfig:\r\n    \"\"\"\r\n    Load a SystemConfig from a JSON or YAML file.\r\n    \"\"\"\r\n    path = Path(path)\r\n    raw = _load_yaml_or_json(path)\r\n\r\n    def r_rng(d) -> Range:\r\n        return Range(start=d[\"start\"], stop=d[\"stop\"])\r\n\r\n    def r_rf_config(d) -> RfConfiguration:\r\n        if1_sb = d.get(\"if1_subband\")\r\n        return RfConfiguration(\r\n            config_id=str(d[\"config_id\"]),\r\n            rf_center=d[\"rf_center\"],\r\n            rf_bandwidth=d[\"rf_bandwidth\"],\r\n            if1_subband=r_rng(if1_sb) if if1_sb is not None else None,\r\n        )\r\n\r\n    def r_spur_entry(d) -> SpurTableEntry:\r\n        return SpurTableEntry(\r\n            m=d[\"m\"],\r\n            n=d[\"n\"],\r\n            level_dbc=d[\"level_dbc\"],\r\n            if_range=r_rng(d[\"if_range\"]),\r\n            lo_range=r_rng(d[\"lo_range\"]),\r\n            rf_range=r_rng(d[\"rf_range\"]),\r\n            lo_tone_type=d.get(\"lo_tone_type\"),\r\n        )\r\n\r\n    def r_spur_envelope(d) -> MixerSpurEnvelopePolicy:\r\n        return MixerSpurEnvelopePolicy(\r\n            m_max=d[\"m_max\"],\r\n            n_max=d[\"n_max\"],\r\n            enforce_envelope_completeness=d.get(\"enforce_envelope_completeness\", False),\r\n            unspecified_floor_dbc=d.get(\"unspecified_floor_dbc\"),\r\n        )\r\n\r\n    def r_mixer_ranges(d) -> MixerRanges:\r\n        return MixerRanges(\r\n            if_range=r_rng(d[\"if_range\"]),\r\n            lo_range=r_rng(d[\"lo_range\"]),\r\n            rf_range=r_rng(d[\"rf_range\"]),\r\n        )\r\n\r\n    def r_mixer(d) -> MixerConfig:\r\n        return MixerConfig(\r\n            name=d[\"name\"],\r\n            spur_table=[r_spur_entry(st) for st in d.get(\"spur_table\", [])],\r\n            spur_envelope=r_spur_envelope(d[\"spur_envelope\"]),\r\n            isolation=MixerIsolation(\r\n                lo_to_rf_dbc=d[\"isolation\"][\"lo_to_rf_dbc\"],\r\n                if_to_rf_dbc=d[\"isolation\"][\"if_to_rf_dbc\"],\r\n            ),\r\n            ranges=r_mixer_ranges(d[\"ranges\"]),\r\n            desired_m=d.get(\"desired_m\", 1),\r\n            desired_n=d.get(\"desired_n\", 1),\r\n        )\r\n\r\n    def r_lo(d) -> LOSynthConfig:\r\n        return LOSynthConfig(\r\n            name=d[\"name\"],\r\n            freq_range=r_rng(d[\"freq_range\"]),\r\n            grid_step=d[\"grid_step\"],\r\n            pfd_frequency=d.get(\"pfd_frequency\"),\r\n            harmonics=[\r\n                LOHarmonic(order=h[\"order\"], level_dbc=h[\"level_dbc\"])\r\n                for h in d.get(\"harmonics\", [])\r\n            ],\r\n            pll_spurs=[\r\n                PLLSpur(offset_multiple=s[\"offset_multiple\"], level_dbc=s[\"level_dbc\"])\r\n                for s in d.get(\"pll_spurs\", [])\r\n            ],\r\n        )\r\n\r\n    def r_if2_constraints(d) -> IF2BankConstraints:\r\n        return IF2BankConstraints(\r\n            min_filters=d[\"min_filters\"],\r\n            max_filters=d[\"max_filters\"],\r\n            fc_range=r_rng(d[\"fc_range\"]),\r\n            bw_range=r_rng(d[\"bw_range\"]),\r\n            slope_range=(d[\"slope_range\"][0], d[\"slope_range\"][1]),\r\n            feasibility_margin_hz=d.get(\"feasibility_margin_hz\", 0.0),\r\n        )\r\n\r\n    def r_filters(d) -> FilterConfig:\r\n        return FilterConfig(\r\n            if2_constraints=r_if2_constraints(d[\"if2_constraints\"]),\r\n            rf_bpf_csv_path=d[\"rf_bpf_csv_path\"],\r\n        )\r\n\r\n    def r_spur_limits(d) -> SpurLimitsConfig:\r\n        mask_cfg = d.get(\"mask\")\r\n        mask = None\r\n        if mask_cfg:\r\n            mask = RFMaskConfig(\r\n                csv_path=mask_cfg.get(\"csv_path\"),\r\n                apply_in_band=mask_cfg.get(\"apply_in_band\", True),\r\n                apply_out_of_band=mask_cfg.get(\"apply_out_of_band\", True),\r\n            )\r\n        oob_range = d.get(\"out_of_band_range\")\r\n        return SpurLimitsConfig(\r\n            in_band_limit_dbc=d.get(\"in_band_limit_dbc\"),\r\n            out_of_band_limit_dbc=d.get(\"out_of_band_limit_dbc\"),\r\n            mask=mask,\r\n            out_of_band_range=r_rng(oob_range) if oob_range else None,\r\n            mask_eval_mode=d.get(\"mask_eval_mode\", \"center\"),\r\n        )\r\n\r\n    def r_grids(d) -> GridsAndPerformanceConfig:\r\n        return GridsAndPerformanceConfig(\r\n            if1_grid_step_hz=d[\"if1_grid_step_hz\"],\r\n            spur_integration_step_hz=d[\"spur_integration_step_hz\"],\r\n            max_if1_harmonic_order=d[\"max_if1_harmonic_order\"],\r\n            min_spur_level_considered_dbc=d.get(\"min_spur_level_considered_dbc\", -120.0),\r\n            max_lo_candidates_per_rf=d.get(\"max_lo_candidates_per_rf\", 50),\r\n            max_if2_bank_candidates=d.get(\"max_if2_bank_candidates\", 50),\r\n            coarse_spur_margin_min_db=d.get(\"coarse_spur_margin_min_db\", -10.0),\r\n            mixer2_if2_focus_margin_hz=d.get(\"mixer2_if2_focus_margin_hz\", 0.0),\r\n            parallel=d.get(\"parallel\", True),\r\n            use_numba=d.get(\"use_numba\", False),\r\n            min_lo_candidates_per_rf_after_coarse=d.get(\r\n            \"min_lo_candidates_per_rf_after_coarse\", 1\r\n            )\r\n        )\r\n        \r\n    def _sanity_check_mixer_spur_config(m: MixerConfig) -> None:\r\n        \"\"\"Emit warnings for common spur-table pitfalls.\"\"\"\r\n        env = m.spur_envelope\r\n        desired = (m.desired_m, m.desired_n)\r\n        in_table = any(e.m == desired[0] and e.n == desired[1] for e in m.spur_table)\r\n        within_env = (abs(desired[0]) <= env.m_max) and (abs(desired[1]) <= env.n_max)\r\n\r\n        if in_table:\r\n            warnings.warn(\r\n                f\"Mixer '{m.name}': spur_table contains the desired fundamental \"\r\n                f\"(m={desired[0]}, n={desired[1]}). This entry will be ignored \"\r\n                \"as a spur; ensure spur levels are defined relative to this \"\r\n                \"desired product.\",\r\n                RuntimeWarning,\r\n            )\r\n\r\n        if env.unspecified_floor_dbc is not None and within_env and not in_table:\r\n            warnings.warn(\r\n                f\"Mixer '{m.name}': spur_envelope covers the desired fundamental \"\r\n                f\"(m={desired[0]}, n={desired[1]}) and unspecified_floor_dbc=\"\r\n                f\"{env.unspecified_floor_dbc:.1f} dBc is set, but there is no \"\r\n                \"explicit spur_table entry for this family. The tool will treat \"\r\n                \"this family as the desired path (not as a spur), but the \"\r\n                \"envelope configuration may be misleading.\",\r\n                RuntimeWarning,\r\n            )\r\n            \r\n    mixer1_cfg = r_mixer(raw[\"mixer1\"])\r\n    mixer2_cfg = r_mixer(raw[\"mixer2\"])\r\n    _sanity_check_mixer_spur_config(mixer1_cfg)\r\n    _sanity_check_mixer_spur_config(mixer2_cfg)\r\n\r\n    return SystemConfig(\r\n        if1_band=r_rng(raw[\"if1_band\"]),\r\n        rf_band=r_rng(raw[\"rf_band\"]),\r\n        rf_configurations=[r_rf_config(rc) for rc in raw[\"rf_configurations\"]],\r\n        non_inverting_mapping_required=raw.get(\"non_inverting_mapping_required\", True),\r\n        mixer1=r_mixer(raw[\"mixer1\"]),\r\n        mixer2=r_mixer(raw[\"mixer2\"]),\r\n        lo1=r_lo(raw[\"lo1\"]),\r\n        lo2=r_lo(raw[\"lo2\"]),\r\n        filters=r_filters(raw[\"filters\"]),\r\n        spur_limits=r_spur_limits(raw[\"spur_limits\"]),\r\n        grids=r_grids(raw[\"grids\"]),\r\n        if1_harmonics_dbc={int(k): float(v) for k, v in raw.get(\"if1_harmonics_dbc\", {}).items()},\r\n        description=raw.get(\"description\"),\r\n    )",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "filters.py",
              "path": "src\\buc_planner\\filters.py",
              "size": 6136,
              "content_truncated": false,
              "contents": "# src/buc_planner/filters.py\r\nfrom __future__ import annotations\r\n\r\nfrom dataclasses import dataclass\r\nfrom pathlib import Path\r\nfrom typing import Tuple, Optional\r\n\r\nimport numpy as np\r\n\r\nfrom .config_models import Freq, dB, IF2BankConstraints, Range\r\n\r\n\r\n@dataclass\r\nclass IF2Filter:\r\n    \"\"\"\r\n    Planning-grade IF2 BPF model:\r\n        A(f) = 0 dB inside [fc - BW/2, fc + BW/2]\r\n             = S * log10(|f - fc| / (BW/2))  outside, where S < 0 (dB/decade)\r\n    \"\"\"\r\n    filter_id: str\r\n    fc: Freq\r\n    bw: Freq\r\n    slope_db_per_decade: dB\r\n\r\n    def attenuation_db(self, freq: np.ndarray) -> np.ndarray:\r\n        \"\"\"Return attenuation A(f) in dB for vector freq.\"\"\"\r\n        f = np.asarray(freq, dtype=float)\r\n\r\n        # Guard against zero / negative BW: treat as extremely narrow band.\r\n        # This avoids division by zero while still keeping behaviour well-defined.\r\n        half_bw = max(self.bw / 2.0, 1e-12)\r\n\r\n        # in-band: 0 dB\r\n        in_band = (f >= self.fc - half_bw) & (f <= self.fc + half_bw)\r\n        out_band = ~in_band\r\n        att = np.zeros_like(f, dtype=float)\r\n\r\n        if np.any(out_band):\r\n            # normalize offset to band edge\r\n            offset = np.abs(f[out_band] - self.fc) / half_bw\r\n            offset[offset <= 0] = 1e-12\r\n            att[out_band] = self.slope_db_per_decade * np.log10(offset)\r\n\r\n        return att\r\n\r\n\r\n@dataclass\r\nclass RFFilter:\r\n    \"\"\"\r\n    RF BPF defined by CSV: frequency vs attenuation (dB). Attenuation outside CSV\r\n    range is 'hold last value'.\r\n    \"\"\"\r\n    freqs: np.ndarray\r\n    att_db: np.ndarray\r\n\r\n    @classmethod\r\n    def from_csv(cls, path: str | Path) -> \"RFFilter\":\r\n        path = Path(path)\r\n        data = np.genfromtxt(path, delimiter=\",\", comments=\"#\", skip_header=0)\r\n\r\n        # Handle single-row and sanity-check shape\r\n        if data.ndim == 1:\r\n            data = data.reshape(1, -1)\r\n\r\n        if data.size == 0 or data.shape[1] < 2:\r\n            raise ValueError(\r\n                f\"RF BPF CSV '{path}' must have at least two columns (freq, attenuation_db).\"\r\n            )\r\n\r\n        # If the first row contains NaNs and there are more rows, treat it as a header.\r\n        if data.shape[0] > 1 and (np.isnan(data[0, 0]) or np.isnan(data[0, 1])):\r\n            data = data[1:, :]\r\n            if data.size == 0 or data.shape[1] < 2:\r\n                raise ValueError(\r\n                    f\"RF BPF CSV '{path}' has only a header and no data rows.\"\r\n                )\r\n\r\n        freqs = data[:, 0].astype(float)\r\n        att_db = data[:, 1].astype(float)\r\n\r\n        # Ensure increasing frequency\r\n        idx = np.argsort(freqs)\r\n        return cls(freqs=freqs[idx], att_db=att_db[idx])\r\n    \r\n    def attenuation_db(self, freq: np.ndarray) -> np.ndarray:\r\n        \"\"\"\r\n        Interpolated attenuation A(f) in dB for vector freq.\r\n\r\n        - Linear interpolation within [min(freqs), max(freqs)]\r\n        - Hold nearest endpoint value outside that range\r\n        \"\"\"\r\n        f = np.asarray(freq, dtype=float)\r\n        if self.freqs.size == 0:\r\n            # Extremely defensive; should not happen with a valid CSV\r\n            return np.zeros_like(f, dtype=float)\r\n\r\n        fmin = self.freqs[0]\r\n        fmax = self.freqs[-1]\r\n        f_clamped = np.clip(f, fmin, fmax)\r\n        return np.interp(f_clamped, self.freqs, self.att_db)\r\n\r\n\r\n\r\n@dataclass\r\nclass IF2Bank:\r\n    filters: list[IF2Filter]\r\n    # Optional mapping from RF configuration ID -> filter_id\r\n    config_to_filter_id: dict[str, str] | None = None\r\n\r\n    def select_filter_for_config(self, config_id: str) -> IF2Filter:\r\n        \"\"\"\r\n        Return the IF2Filter assigned to this RF configuration.\r\n\r\n        If a config→filter mapping is available (e.g. produced by the optimizer),\r\n        it is used. Otherwise a deterministic round-robin mapping is used as a\r\n        fallback so that the bank remains usable in simple/manual scenarios.\r\n        \"\"\"\r\n        if not self.filters:\r\n            raise RuntimeError(\r\n                \"IF2Bank has no filters configured; cannot select a filter for \"\r\n                f\"config_id='{config_id}'.\"\r\n            )\r\n\r\n        if self.config_to_filter_id and config_id in self.config_to_filter_id:\r\n            fid = self.config_to_filter_id[config_id]\r\n            for f in self.filters:\r\n                if f.filter_id == fid:\r\n                    return f\r\n            # If the mapping points at a missing filter, fall back below.\r\n\r\n        # Fallback: deterministic round-robin based on a stable hash of the ID.\r\n        # We avoid Python's built-in hash(), which is randomized per process.\r\n        idx = (sum(ord(c) for c in config_id) % len(self.filters))\r\n        return self.filters[idx]\r\n\r\n\r\ndef design_single_if2_filter_for_band(\r\n    band: Range,\r\n    constraints: IF2BankConstraints,\r\n    default_slope_db_per_decade: dB = -60.0,\r\n) -> IF2Filter:\r\n    \"\"\"\r\n    Create an IF2Filter that minimally covers the given IF2 band given constraints.\r\n    This is a building block used by the IF2 bank designer.\r\n\r\n    Very simple heuristic:\r\n      * fc = midpoint of band, clamped to fc_range\r\n      * bw = band.width * (1 + small_margin), clamped to bw_range\r\n    \"\"\"\r\n    band_center = 0.5 * (band.start + band.stop)\r\n    band_bw = band.width\r\n\r\n    # apply margin: we allow constraints.feasibility_margin_hz as extra\r\n    bw_margin = constraints.feasibility_margin_hz\r\n    target_bw = band_bw + 2 * bw_margin\r\n\r\n    # clamp to ranges\r\n    fc = np.clip(band_center, constraints.fc_range.start, constraints.fc_range.stop)\r\n    bw_min, bw_max = constraints.bw_range.start, constraints.bw_range.stop\r\n    bw = float(np.clip(target_bw, bw_min, bw_max))\r\n\r\n    if bw <= 0.0:\r\n        raise ValueError(\r\n            \"Computed IF2 filter bandwidth is non-positive. \"\r\n            \"Check IF2 bw_range and feasibility_margin_hz constraints.\"\r\n        )\r\n\r\n    s_min, s_max = constraints.slope_range\r\n    slope = float(np.clip(default_slope_db_per_decade, s_min, s_max))\r\n\r\n    return IF2Filter(\r\n        filter_id=f\"if2_auto_{band_center:.0f}\",\r\n        fc=fc,\r\n        bw=bw,\r\n        slope_db_per_decade=slope,\r\n    )",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "if2_bank.py",
              "path": "src\\buc_planner\\if2_bank.py",
              "size": 10024,
              "content_truncated": false,
              "contents": "# src/buc_planner/if2_bank.py\r\nfrom __future__ import annotations\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Dict, Optional, Mapping\r\nfrom collections import defaultdict\r\n\r\nimport numpy as np\r\nfrom copy import deepcopy\r\n\r\nfrom .config_models import IF2BankConstraints, Range\r\nfrom .filters import IF2Filter, IF2Bank, design_single_if2_filter_for_band\r\nfrom .los import LOPlanCandidate\r\nfrom .spur_engine import IF2SpurControlRegion \r\n\r\n\r\n\r\n@dataclass\r\nclass IF2BankDesignResult:\r\n    bank: IF2Bank\r\n    config_to_filter_id: Dict[str, str]\r\n\t\r\n\t\r\ndef _merge_ranges(ranges: list[Range]) -> list[Range]:\r\n    \"\"\"Union of 1D ranges, returning disjoint, sorted intervals.\"\"\"\r\n    if not ranges:\r\n        return []\r\n    ranges_sorted = sorted(ranges, key=lambda r: r.start)\r\n    merged: list[Range] = []\r\n    cur = ranges_sorted[0]\r\n    for r in ranges_sorted[1:]:\r\n        if r.start <= cur.stop:\r\n            cur = Range(start=cur.start, stop=max(cur.stop, r.stop))\r\n        else:\r\n            merged.append(cur)\r\n            cur = r\r\n    merged.append(cur)\r\n    return merged\r\n\r\n\r\ndef design_if2_bank_for_lo_plans(\r\n    lo_plans: List[LOPlanCandidate],\r\n    constraints: IF2BankConstraints,\r\n    spur_control_regions: Optional[Mapping[str, List[IF2SpurControlRegion]]] = None,\r\n    target_n_filters: Optional[int] = None,\r\n) -> IF2BankDesignResult:\r\n    \"\"\"\r\n    Heuristic IF2 bank design.\r\n\r\n    Inputs:\r\n      * lo_plans:           one LO plan per RF configuration.\r\n      * spur_control_regions:\r\n            optional dict config_id -> list[IF2SpurControlRegion] (IF2 regions\r\n            where we want additional rejection). These come from the coarse\r\n            spur pass in spur_engine and include a required_rejection_db depth.\r\n      * constraints:        IF2 bank constraints.\r\n      * target_n_filters:   desired number of filters (will be clamped\r\n            to [min_filters, max_filters]).\r\n\r\n    Strategy:\r\n      1. For each config, build a \"design band\" composed of:\r\n           - mandatory desired IF2 band (from LO plan),\r\n           - optional spur-control regions (merged only for frequency\r\n             keep-away).\r\n         We keep:\r\n           - desired IF2 band driving passband center/BW.\r\n           - spur-control regions influencing both passband width\r\n             (avoid putting edges on top of them) and minimum required\r\n             out-of-band attenuation (via slope selection).\r\n\r\n      2. Create one provisional filter per config:\r\n           - fc ~ center of desired IF2 band, clamped to fc_range.\r\n           - bw ~ desired band width + feasibility_margin_hz, clamped.\r\n           - slope chosen such that, where possible, attenuation at the\r\n             nearest spur-control region meets required_rejection_db,\r\n             subject to slope_range.\r\n\r\n      3. Greedily merge filters by closeness of fc until we hit\r\n         target_n_filters (or constraints.min_filters by default).\r\n\r\n      4. Map each configuration to the filter whose passband best covers\r\n         its desired IF2 band.\r\n    \"\"\"\r\n    bands_by_config: Dict[str, Range] = {p.config_id: p.if2_band for p in lo_plans}\r\n\r\n    # 1) Collect per-config spur-control regions (full objects)\r\n    cfg_control_regions: Dict[str, List[IF2SpurControlRegion]] = defaultdict(list)\r\n    if spur_control_regions:\r\n        for cfg_id, regs in spur_control_regions.items():\r\n            if not regs:\r\n                continue\r\n            cfg_control_regions[cfg_id].extend(regs)\r\n\r\n    filter_defs: Dict[str, IF2Filter] = {}\r\n    for plan in lo_plans:\r\n        config_id = plan.config_id\r\n        desired_band = bands_by_config[config_id]\r\n\r\n        regions = cfg_control_regions.get(config_id, [])\r\n        # For BW tightening we only need frequency ranges\r\n        control_ranges_merged: List[Range] = []\r\n        if regions:\r\n            control_ranges_merged = _merge_ranges(\r\n                [Range(r.freq_start, r.freq_stop) for r in regions]\r\n            )\r\n\r\n        band_center = 0.5 * (desired_band.start + desired_band.stop)\r\n        desired_bw = desired_band.width\r\n\r\n        bw_margin = constraints.feasibility_margin_hz\r\n        bw_min = constraints.bw_range.start\r\n        bw_max = constraints.bw_range.stop\r\n\r\n        # Start with desired BW + margin\r\n        target_bw = desired_bw + 2 * bw_margin\r\n\r\n        # Shrink BW so that passband edges don't sit unnecessarily\r\n        # close to spur-control regions.\r\n        if control_ranges_merged and target_bw > 0.0:\r\n            half_bw = 0.5 * target_bw\r\n            pass_lo = band_center - half_bw\r\n            pass_hi = band_center + half_bw\r\n\r\n            def nearest_control_edge_distance() -> float:\r\n                dmin = float(\"inf\")\r\n                for r in control_ranges_merged:\r\n                    for edge in (r.start, r.stop):\r\n                        dmin = min(\r\n                            dmin,\r\n                            abs(edge - pass_lo),\r\n                            abs(edge - pass_hi),\r\n                        )\r\n                return dmin\r\n\r\n            d = nearest_control_edge_distance()\r\n            if d > 0.0 and d < half_bw:\r\n                # Bring edges away from the closest control-region edge,\r\n                # but never shrink below the desired IF2 bandwidth.\r\n                new_half_bw = max(desired_bw * 0.5, d * 0.8)\r\n                target_bw = 2.0 * new_half_bw\r\n\r\n        # Clamp BW and center to constraints\r\n        target_bw = float(max(bw_min, min(bw_max, target_bw)))\r\n        fc = float(\r\n            max(constraints.fc_range.start, min(constraints.fc_range.stop, band_center))\r\n        )\r\n\r\n        # 2) Slope: use required_rejection_db where possible\r\n        s_min, s_max = constraints.slope_range\r\n        # Start from mid of slope_range as neutral\r\n        slope = (s_min + s_max) * 0.5\r\n\r\n        if regions and target_bw > 0.0:\r\n            half_bw = 0.5 * target_bw\r\n            required_slopes: List[float] = []\r\n\r\n            for reg in regions:\r\n                # Consider both edges of the region; we want the closest\r\n                # point *outside* the passband.\r\n                for edge in (reg.freq_start, reg.freq_stop):\r\n                    dist = abs(edge - fc)\r\n                    if dist <= half_bw:\r\n                        # Region edge inside passband: we cannot use\r\n                        # out-of-band roll-off to meet this requirement.\r\n                        continue\r\n                    offset_ratio = dist / half_bw\r\n                    if offset_ratio <= 1.0:\r\n                        continue\r\n                    if reg.required_rejection_db <= 0.0:\r\n                        continue\r\n                    # A(f) = S * log10(offset_ratio), S < 0.\r\n                    # We need A(f) <= -required_rejection_db.\r\n                    # => S <= -required / log10(offset_ratio).\r\n                    s_req = -reg.required_rejection_db / np.log10(offset_ratio)\r\n                    required_slopes.append(s_req)\r\n\r\n            if required_slopes:\r\n                # Pick the steepest (most negative) requirement\r\n                worst_s_req = min(required_slopes)\r\n                slope = worst_s_req\r\n            else:\r\n                # No geometric point where we can use the skirt to help;\r\n                # bias slightly towards a steeper slope.\r\n                slope = min(slope, s_min)\r\n\r\n        # Clamp slope to allowed range\r\n        slope = max(s_min, min(slope, s_max))\r\n\r\n        f = IF2Filter(\r\n            filter_id=f\"if2_auto_{config_id}\",\r\n            fc=fc,\r\n            bw=target_bw,\r\n            slope_db_per_decade=float(slope),\r\n        )\r\n        filter_defs[config_id] = f\r\n\r\n    filters: List[IF2Filter] = list(filter_defs.values())\r\n\r\n    # 2) Determine desired number of filters\r\n    if target_n_filters is None:\r\n        desired = constraints.min_filters\r\n    else:\r\n        desired = max(constraints.min_filters, min(target_n_filters, constraints.max_filters))\r\n    desired = max(desired, 1)\r\n\r\n    # 3) Greedy merge by fc\r\n    while len(filters) > desired:\r\n        min_dist = float(\"inf\")\r\n        merge_i = merge_j = None\r\n        for i in range(len(filters)):\r\n            for j in range(i + 1, len(filters)):\r\n                d = abs(filters[i].fc - filters[j].fc)\r\n                if d < min_dist:\r\n                    min_dist = d\r\n                    merge_i, merge_j = i, j\r\n        if merge_i is None or merge_j is None:\r\n            break\r\n\r\n        f1 = filters[merge_i]\r\n        f2 = filters[merge_j]\r\n        merged_band = Range(\r\n            start=min(f1.fc - f1.bw / 2, f2.fc - f2.bw / 2),\r\n            stop=max(f1.fc + f1.bw / 2, f2.fc + f2.bw / 2),\r\n        )\r\n\r\n        # Preserve the steepest slope requirement of the merged filters\r\n        merged_default_slope = min(\r\n            f1.slope_db_per_decade,\r\n            f2.slope_db_per_decade,\r\n        )\r\n\r\n        merged = design_single_if2_filter_for_band(\r\n            merged_band,\r\n            constraints,\r\n            default_slope_db_per_decade=merged_default_slope,   # <-- NEW\r\n        )\r\n        filters[merge_i] = merged\r\n        del filters[merge_j]\r\n\r\n    while len(filters) < desired:\r\n        # Use a deep copy to avoid aliasing the same IF2Filter instance.\r\n        filters.append(deepcopy(filters[-1]))\r\n\r\n    # 4) Map each config to best filter (coverage of desired IF2 band)\r\n    mapping: Dict[str, str] = {}\r\n    for plan in lo_plans:\r\n        config_id = plan.config_id\r\n        band = bands_by_config[config_id]\r\n        best_id = None\r\n        best_score = float(\"inf\")\r\n        for f in filters:\r\n            f_lo = f.fc - f.bw / 2\r\n            f_hi = f.fc + f.bw / 2\r\n            score = abs(band.start - f_lo) + abs(band.stop - f_hi)\r\n            if score < best_score:\r\n                best_score = score\r\n                best_id = f.filter_id\r\n        mapping[config_id] = best_id\r\n\r\n    bank = IF2Bank(filters=filters, config_to_filter_id=mapping)\r\n    return IF2BankDesignResult(bank=bank, config_to_filter_id=mapping)",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "los.py",
              "path": "src\\buc_planner\\los.py",
              "size": 7521,
              "content_truncated": false,
              "contents": "# src/buc_planner/los.py\r\nfrom __future__ import annotations\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import Iterable, List, Tuple\r\n\r\nimport numpy as np\r\nimport logging\r\n\r\nfrom .config_models import LOSynthConfig, Range, RfConfiguration, SystemConfig, Freq\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\n_MAX_LO_GRID_POINTS = 20000  # simple safety cap\r\n\r\n@dataclass(frozen=True)\r\nclass LOSignCombination:\r\n    \"\"\"\r\n    sign1, sign2 are ±1 representing mixer senses:\r\n        Mixer1: IF2 = LO1 + sign1 * IF1\r\n        Mixer2: RF  = LO2 + sign2 * IF2\r\n\r\n    Overall IF1→RF derivative sign ~ sign1 * sign2.\r\n    \"\"\"\r\n    sign1: int\r\n    sign2: int\r\n\r\n    def is_non_inverting(self) -> bool:\r\n        return self.sign1 * self.sign2 > 0\r\n\r\n\r\n@dataclass\r\nclass LOPlanCandidate:\r\n    config_id: str\r\n    lo1_freq: Freq\r\n    lo2_freq: Freq\r\n    sign_combo: LOSignCombination\r\n    if2_band: Range  # required IF2 band for desired path\r\n    rf_band: Range   # resulting RF band from desired path\r\n\r\n\r\ndef _enumerate_lo_grid(lo_cfg: LOSynthConfig) -> np.ndarray:\r\n    \"\"\"Enumerate LO grid from freq_range with step size.\r\n\r\n    A simple guard is applied to avoid generating excessively large grids:\r\n    if the number of points would exceed _MAX_LO_GRID_POINTS, the grid is\r\n    truncated and a warning is logged.\r\n    \"\"\"\r\n    start = lo_cfg.freq_range.start\r\n    stop = lo_cfg.freq_range.stop\r\n    step = lo_cfg.grid_step\r\n\r\n    if step <= 0.0:\r\n        raise ValueError(\r\n            f\"LO synth '{lo_cfg.name}': grid_step must be > 0 (got {step}).\"\r\n        )\r\n\r\n    span = stop - start\r\n    if span <= 0.0:\r\n        return np.array([start], dtype=float)\r\n\r\n    n_steps = int(np.floor(span / step)) + 1\r\n    if n_steps > _MAX_LO_GRID_POINTS:\r\n        logger.warning(\r\n            \"LO synth '%s': grid between %.6g and %.6g Hz with step %.6g Hz \"\r\n            \"would create %d points; truncating to %d points. Consider \"\r\n            \"narrowing freq_range or increasing grid_step.\",\r\n            lo_cfg.name,\r\n            start,\r\n            stop,\r\n            step,\r\n            n_steps,\r\n            _MAX_LO_GRID_POINTS,\r\n        )\r\n        n_steps = _MAX_LO_GRID_POINTS\r\n\r\n    return start + np.arange(n_steps) * step\r\n\r\ndef generate_lo_plan_candidates_for_config(\r\n    cfg: SystemConfig,\r\n    rf_conf: RfConfiguration,\r\n    max_candidates: int | None = None,\r\n) -> List[LOPlanCandidate]:\r\n    \"\"\"\r\n    Enumerate coarse LO1/LO2 candidates for a given RF configuration,\r\n    obeying synthesizer ranges, mixer ranges, and non-inverting mapping.\r\n\r\n    Strategy:\r\n      * Build an IF1 grid over the (sub-)band clipped to Mixer1 IF range.\r\n      * For each LO1/sign1:\r\n          - Derive IF2(f_IF1) and check Mixer1 RF range.\r\n          - Ensure full IF1 band lies within Mixer1 IF range (spec 6.4).\r\n          - Intersect IF2 band with Mixer2 IF range.\r\n      * For each LO2/sign2:\r\n          - Derive RF(f_IF1) on the IF1 grid.\r\n          - Enforce strict monotonic IF1->RF mapping (if requested).\r\n          - Ensure RF(f_IF1) covers the RF configuration band and stays\r\n            inside Mixer2 RF & global RF bands over entire IF1 grid.\r\n    \"\"\"\r\n    # Effective IF1 band for this configuration\r\n    if1_band_cfg = rf_conf.if1_subband or cfg.if1_band\r\n\r\n    # Clip IF1 band to Mixer1 IF range; if no overlap, configuration is invalid\r\n    m1_if_range = cfg.mixer1.ranges.if_range\r\n    if1_band = if1_band_cfg.intersect(m1_if_range)\r\n    if if1_band is None or if1_band.width <= 0:\r\n        raise RuntimeError(\r\n            f\"RF config '{rf_conf.config_id}' IF1 band lies outside Mixer1 IF range.\"\r\n        )\r\n\r\n    lo1_grid = _enumerate_lo_grid(cfg.lo1)\r\n    lo2_grid = _enumerate_lo_grid(cfg.lo2)\r\n\r\n    # IF1 grid for mapping checks\r\n    step = cfg.grids.if1_grid_step_hz\r\n    if step <= 0:\r\n        # Fallback: coarse 32-point grid if misconfigured\r\n        n_pts = 32\r\n        if1_grid = np.linspace(if1_band.start, if1_band.stop, n_pts)\r\n    else:\r\n        n_pts = max(int(np.floor(if1_band.width / step)) + 1, 3)\r\n        if1_grid = np.linspace(if1_band.start, if1_band.stop, n_pts)\r\n\r\n    lo_sign_combos = [\r\n        LOSignCombination(+1, +1),\r\n        LOSignCombination(-1, -1),\r\n    ]\r\n    if not cfg.non_inverting_mapping_required:\r\n        lo_sign_combos.extend([\r\n            LOSignCombination(+1, -1),\r\n            LOSignCombination(-1, +1),\r\n        ])\r\n\r\n    target_rf_lo = rf_conf.rf_center - 0.5 * rf_conf.rf_bandwidth\r\n    target_rf_hi = rf_conf.rf_center + 0.5 * rf_conf.rf_bandwidth\r\n\r\n    m1 = cfg.mixer1\r\n    m2 = cfg.mixer2\r\n\r\n    candidates: List[LOPlanCandidate] = []\r\n\r\n    for lo1_freq in lo1_grid:\r\n        # Mixer1 LO range\r\n        if not m1.ranges.lo_range.contains(lo1_freq):\r\n            continue\r\n\r\n        for sign_combo in lo_sign_combos:\r\n            if cfg.non_inverting_mapping_required and not sign_combo.is_non_inverting():\r\n                continue\r\n\r\n            # IF2 mapping from IF1 grid\r\n            if sign_combo.sign1 > 0:\r\n                if2_vals = lo1_freq + sign_combo.sign1 * if1_grid\r\n            else:\r\n                if2_vals = lo1_freq - if1_grid  # LO1 - IF1\r\n\r\n            if2_band = Range(start=float(if2_vals.min()), stop=float(if2_vals.max()))\r\n\r\n            # Mixer1 RF range is effectively IF2 node; require full IF2 band inside\r\n            if not (m1.ranges.rf_range.contains(if2_band.start) and\r\n                    m1.ranges.rf_range.contains(if2_band.stop)):\r\n                continue\r\n\r\n            # Mixer2 IF range: require IF2 band fully inside Mixer2 IF range\r\n            m2_if = m2.ranges.if_range\r\n            if not (m2_if.contains(if2_band.start) and m2_if.contains(if2_band.stop)):\r\n                continue\r\n\r\n            for lo2_freq in lo2_grid:\r\n                # Mixer2 LO range\r\n                if not m2.ranges.lo_range.contains(lo2_freq):\r\n                    continue\r\n\r\n                # RF mapping for IF1 grid\r\n                if sign_combo.sign2 > 0:\r\n                    rf_vals = lo2_freq + sign_combo.sign2 * if2_vals\r\n                else:\r\n                    rf_vals = lo2_freq - if2_vals  # LO2 - IF2\r\n\r\n                rf_band = Range(start=float(rf_vals.min()), stop=float(rf_vals.max()))\r\n\r\n                # Strictly monotonic increasing mapping if requested\r\n                if cfg.non_inverting_mapping_required:\r\n                    if not np.all(np.diff(rf_vals) > 0.0):\r\n                        continue\r\n\r\n                # RF range coverage for this configuration\r\n                if not (rf_band.start <= target_rf_lo and rf_band.stop >= target_rf_hi):\r\n                    continue\r\n\r\n                # Mixer2 RF range and global RF band must contain the entire RF band\r\n                if not (m2.ranges.rf_range.contains(rf_band.start) and\r\n                        m2.ranges.rf_range.contains(rf_band.stop)):\r\n                    continue\r\n                if not (cfg.rf_band.contains(rf_band.start) and\r\n                        cfg.rf_band.contains(rf_band.stop)):\r\n                    continue\r\n\r\n                cand = LOPlanCandidate(\r\n                    config_id=rf_conf.config_id,\r\n                    lo1_freq=lo1_freq,\r\n                    lo2_freq=lo2_freq,\r\n                    sign_combo=sign_combo,\r\n                    if2_band=if2_band,\r\n                    rf_band=rf_band,\r\n                )\r\n                candidates.append(cand)\r\n                if max_candidates is not None and len(candidates) >= max_candidates:\r\n                    return candidates\r\n\r\n    return candidates",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "mixers.py",
              "path": "src\\buc_planner\\mixers.py",
              "size": 9710,
              "content_truncated": false,
              "contents": "# src/buc_planner/mixers.py\r\nfrom __future__ import annotations\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Optional, Set, Tuple\r\n\r\nimport numpy as np\r\n\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nfrom .config_models import (\r\n    MixerConfig,\r\n    SpurTableEntry,\r\n    Freq,\r\n    dBc,\r\n    Range,\r\n)\r\n\r\n\r\n@dataclass\r\nclass LOTone:\r\n    \"\"\"\r\n    Represents a specific LO tone at the mixer LO port: fundamental, harmonic, or PLL spur.\r\n    \"\"\"\r\n    name: str\r\n    freq: Freq\r\n    level_dbc: dBc  # relative to LO fundamental\r\n\r\n\r\n@dataclass\r\nclass MixerInputBand:\r\n    \"\"\"\r\n    Wideband input used to generate spurs: e.g., IF1 fundamental band, IF1 harmonic,\r\n    or IF2 wideband at Mixer2 input.\r\n    \"\"\"\r\n    name: str\r\n    f_start: Freq\r\n    f_stop: Freq\r\n    level_dbc_integrated: dBc  # integrated power vs IF1 fundamental (0 dBc)\r\n\r\n    @property\r\n    def center(self) -> Freq:\r\n        return 0.5 * (self.f_start + self.f_stop)\r\n\r\n    @property\r\n    def bandwidth(self) -> Freq:\r\n        return self.f_stop - self.f_start\r\n\r\n\r\n@dataclass\r\nclass SpurFamilySpec:\r\n    \"\"\"Resolved spur-family spec combining a table entry and specific LO tone.\"\"\"\r\n    entry: SpurTableEntry\r\n    lo_tone: LOTone\r\n    effective_level_dbc: dBc  # L_spur_table + L_lo_tone if applicable\r\n    mixer_name: str\r\n    used_unspecified_floor: bool = False\r\n\r\n\r\n@dataclass\r\nclass MixerWidebandSpurBand:\r\n    \"\"\"\r\n    Represents wideband spur after a single mixing stage, before filters.\r\n    \"\"\"\r\n    name: str\r\n    mixer_name: str\r\n    m: int\r\n    n: int\r\n    lo_tone_name: str\r\n    input_band_name: str\r\n    center_freq: Freq\r\n    f_start: Freq\r\n    f_stop: Freq\r\n    spur_level_rel_if1_dbc: dBc  # relative to IF1 fundamental integrated power\r\n    used_unspecified_floor: bool = False\r\n    \r\n    @property\r\n    def bandwidth(self) -> Freq:\r\n        \"\"\"Convenience helper: width of the spur band.\"\"\"\r\n        return self.f_stop - self.f_start\r\n\r\n\r\ndef resolve_spur_families_for_tones(\r\n    mixer: MixerConfig,\r\n    lo_tones: List[LOTone],\r\n) -> List[SpurFamilySpec]:\r\n    \"\"\"\r\n    Combine spur table with a set of LO tones, enforcing the (m,n) envelope and\r\n    SpurTableEntry validity ranges.\r\n\r\n    * LO validity is enforced via entry.lo_range.\r\n    * IF and RF validity are enforced later in generate_wideband_spur_band.\r\n    \"\"\"\r\n    specs: List[SpurFamilySpec] = []\r\n\r\n    # 1) Build effective spur table, injecting floor entries if requested\r\n    table_entries: List[SpurTableEntry] = list(mixer.spur_table)\r\n    floor_pairs: Set[Tuple[int, int]] = set()\r\n\r\n    env = mixer.spur_envelope\r\n    desired_pair = (mixer.desired_m, mixer.desired_n)\r\n    existing_pairs = {(e.m, e.n) for e in table_entries}\r\n    missing: List[Tuple[int, int]] = []\r\n    for m in range(-env.m_max, env.m_max + 1):\r\n        for n in range(-env.n_max, env.n_max + 1):\r\n            if n == 0:\r\n                continue  # n != 0 per spec\r\n            # Do not require the desired path to be present as a spur family\r\n            if (m, n) == desired_pair:\r\n                continue\r\n            if (m, n) in existing_pairs:\r\n                continue\r\n            missing.append((m, n))\r\n\r\n    if missing:\r\n        if env.enforce_envelope_completeness and env.unspecified_floor_dbc is None:\r\n            logger.error(\r\n                \"Mixer '%s': spur envelope |m|<=%d, |n|<=%d has %d unspecified (m,n) \"\r\n                \"pairs and no unspecified_floor_dbc configured.\",\r\n                mixer.name,\r\n                env.m_max,\r\n                env.n_max,\r\n                len(missing),\r\n            )\r\n            raise ValueError(\r\n                f\"Mixer '{mixer.name}': spur envelope |m|<={env.m_max}, |n|<={env.n_max} \"\r\n                f\"requires entries for all families; {len(missing)} (m,n) pairs are \"\r\n                f\"unspecified and no unspecified_floor_dbc is configured.\"\r\n            )\r\n        if env.unspecified_floor_dbc is not None:\r\n            logger.warning(\r\n                \"Mixer '%s': applying unspecified_floor_dbc=%.1f dBc to %d missing spur \"\r\n                \"families within envelope |m|<=%d, |n|<=%d.\",\r\n                mixer.name,\r\n                env.unspecified_floor_dbc,\r\n                len(missing),\r\n                env.m_max,\r\n                env.n_max,\r\n            )\r\n            for m_val, n_val in missing:\r\n                table_entries.append(\r\n                    SpurTableEntry(\r\n                        m=m_val,\r\n                        n=n_val,\r\n                        level_dbc=env.unspecified_floor_dbc,\r\n                        if_range=mixer.ranges.if_range,\r\n                        lo_range=mixer.ranges.lo_range,\r\n                        rf_range=mixer.ranges.rf_range,\r\n                        lo_tone_type=\"fundamental\",\r\n                    )\r\n                )\r\n                floor_pairs.add((m_val, n_val))\r\n        elif not env.enforce_envelope_completeness:\r\n            # Spec option (1): warn & ignore unspecified spur families\r\n            logger.warning(\r\n                \"Mixer '%s': spur envelope |m|<=%d, |n|<=%d has %d unspecified spur \"\r\n                \"families which will be ignored.\",\r\n                mixer.name,\r\n                env.m_max,\r\n                env.n_max,\r\n                len(missing),\r\n            )\r\n\r\n    # 2) Resolve against LO tones (enforcing LO range)\r\n    for entry in table_entries:\r\n        if (entry.m, entry.n) == desired_pair:\r\n            continue\r\n        lt = entry.lo_tone_type or \"fundamental\"\r\n        used_floor = (entry.m, entry.n) in floor_pairs\r\n\r\n        def add_spec_for_tone(tone: LOTone, effective_level: dBc) -> None:\r\n            # Enforce LO validity range\r\n            if not entry.lo_range.contains(tone.freq):\r\n                return\r\n            specs.append(\r\n                SpurFamilySpec(\r\n                    entry=entry,\r\n                    lo_tone=tone,\r\n                    effective_level_dbc=effective_level,\r\n                    mixer_name=mixer.name,\r\n                    used_unspecified_floor=used_floor,\r\n                )\r\n            )\r\n\r\n        if lt == \"fundamental\":\r\n            for tone in lo_tones:\r\n                eff_level = entry.level_dbc + tone.level_dbc\r\n                add_spec_for_tone(tone, eff_level)\r\n        elif lt.startswith(\"harmonic_\"):\r\n            for tone in lo_tones:\r\n                if tone.name == lt:\r\n                    add_spec_for_tone(tone, entry.level_dbc)\r\n        elif lt.startswith(\"pll_spur_\"):\r\n            tag = lt[len(\"pll_spur_\") :]\r\n            for tone in lo_tones:\r\n                if not tone.name.startswith(\"pll_spur_\"):\r\n                    continue\r\n                if not tag:\r\n                    add_spec_for_tone(tone, entry.level_dbc)\r\n                else:\r\n                    if tone.name.endswith(tag):\r\n                        add_spec_for_tone(tone, entry.level_dbc)\r\n        else:\r\n            # Unknown lo_tone_type: try exact name match; otherwise treat as \"fundamental\"\r\n            matched = False\r\n            for tone in lo_tones:\r\n                if tone.name == lt:\r\n                    add_spec_for_tone(tone, entry.level_dbc)\r\n                    matched = True\r\n            if not matched:\r\n                for tone in lo_tones:\r\n                    eff_level = entry.level_dbc + tone.level_dbc\r\n                    add_spec_for_tone(tone, eff_level)\r\n\r\n    return specs\r\n\r\n\r\ndef generate_wideband_spur_band(\r\n    input_band: MixerInputBand,\r\n    spur_spec: SpurFamilySpec,\r\n    min_level_considered_dbc: dBc,\r\n) -> Optional[MixerWidebandSpurBand]:\r\n    \"\"\"\r\n    Generate a single wideband spur band for a given input band and spur family spec.\r\n\r\n    Enforces SpurTableEntry.if_range and rf_range by clipping the input and output\r\n    bands; if there is no overlap, the spur is discarded.\r\n\r\n    Bandwidth: |n| * BW_input_eff\r\n    Center frequency: approximately m * f_LO ± n * f_input_center (on the clipped IF band).\r\n    \"\"\"\r\n    m = spur_spec.entry.m\r\n    n = spur_spec.entry.n\r\n    if n == 0:\r\n        return None\r\n\r\n    if spur_spec.effective_level_dbc < min_level_considered_dbc:\r\n        return None\r\n\r\n    # Clip input band by IF validity range\r\n    in_range = Range(start=input_band.f_start, stop=input_band.f_stop)\r\n    clipped_if = in_range.intersect(spur_spec.entry.if_range)\r\n    if clipped_if is None or clipped_if.width <= 0:\r\n        return None\r\n\r\n    f_lo = spur_spec.lo_tone.freq\r\n    f_in_center = 0.5 * (clipped_if.start + clipped_if.stop)\r\n    bw_in = clipped_if.width\r\n    bw_spur = abs(n) * bw_in\r\n\r\n    # Approximate center; sign is implicit in (m, n)\r\n    f_center = m * f_lo + n * f_in_center\r\n    f_start = f_center - 0.5 * bw_spur\r\n    f_stop = f_center + 0.5 * bw_spur\r\n\r\n    # Clip by RF validity range\r\n    spur_range = Range(start=f_start, stop=f_stop)\r\n    clipped_rf = spur_range.intersect(spur_spec.entry.rf_range)\r\n    if clipped_rf is None or clipped_rf.width <= 0:\r\n        return None\r\n\r\n    f_start = clipped_rf.start\r\n    f_stop = clipped_rf.stop\r\n    f_center = 0.5 * (f_start + f_stop)\r\n\r\n    # Spur power relative to IF1 fundamental\r\n    spur_level_rel_if1 = input_band.level_dbc_integrated + spur_spec.effective_level_dbc\r\n\r\n    name = f\"{spur_spec.entry.m},{spur_spec.entry.n}::{input_band.name}@{spur_spec.lo_tone.name}\"\r\n    return MixerWidebandSpurBand(\r\n        name=name,\r\n        mixer_name=spur_spec.mixer_name,\r\n        m=m,\r\n        n=n,\r\n        lo_tone_name=spur_spec.lo_tone.name,\r\n        input_band_name=input_band.name,\r\n        center_freq=f_center,\r\n        f_start=f_start,\r\n        f_stop=f_stop,\r\n        spur_level_rel_if1_dbc=spur_level_rel_if1,\r\n        used_unspecified_floor=spur_spec.used_unspecified_floor,\r\n    )",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "optimizer.py",
              "path": "src\\buc_planner\\optimizer.py",
              "size": 16883,
              "content_truncated": false,
              "contents": "# src/buc_planner/optimizer.py\r\nfrom __future__ import annotations\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Dict, Optional\r\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\r\nimport logging  # NEW\r\n\r\nfrom .config_models import SystemConfig, RfConfiguration, Range\r\nfrom .filters import RFFilter\r\nfrom .los import (\r\n    generate_lo_plan_candidates_for_config,\r\n    LOPlanCandidate,\r\n)\r\nfrom .if2_bank import (\r\n    design_if2_bank_for_lo_plans,\r\n    IF2BankDesignResult,\r\n)\r\nfrom .spur_engine import (\r\n    evaluate_spurs_for_config_and_lo_plan,\r\n    SpurResult,\r\n    ConfigSpurSummary,\r\n\tcoarse_if2_spur_control_regions_for_lo_plan,\r\n\tIF2SpurControlRegion,\r\n    prepare_mask,\r\n)\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\n\r\n@dataclass\r\nclass PlannerResult:\r\n    system_config: SystemConfig\r\n    lo_plans: List[LOPlanCandidate]\r\n    if2_bank_design: IF2BankDesignResult\r\n    spur_results: List[SpurResult]\r\n    summaries: Dict[str, ConfigSpurSummary]\r\n\r\n\r\nclass Planner:\r\n    \"\"\"\r\n    High-level planning engine.\r\n    \"\"\"\r\n\r\n    def __init__(self, cfg: SystemConfig):\r\n        self.cfg = cfg\r\n        self.rf_filter = RFFilter.from_csv(cfg.filters.rf_bpf_csv_path)\r\n        # Pre-load spur mask (if any) once for the whole run\r\n        self._mask_freqs, self._mask_levels = prepare_mask(cfg)\r\n\r\n    def _enumerate_lo_plans(self) -> Dict[str, List[LOPlanCandidate]]:\r\n        \"\"\"\r\n        Enumerate LO candidates for all RF configurations.\r\n\r\n        Returns:\r\n            dict[config_id] -> list[LOPlanCandidate]\r\n        \"\"\"\r\n        cfg = self.cfg\r\n        per_cfg: Dict[str, List[LOPlanCandidate]] = {}\r\n        for rf_conf in cfg.rf_configurations:\r\n            cands = generate_lo_plan_candidates_for_config(\r\n                cfg,\r\n                rf_conf,\r\n                max_candidates=cfg.grids.max_lo_candidates_per_rf,\r\n            )\r\n            if not cands:\r\n                raise RuntimeError(\r\n                    f\"No LO plan candidates found for RF config '{rf_conf.config_id}'. \"\r\n                    \"Check LO ranges, mixer ranges, and RF band.\"\r\n                )\r\n            per_cfg[rf_conf.config_id] = cands\r\n        return per_cfg\r\n\t\t\r\n    def _coarse_prune_lo_candidates(\r\n        self,\r\n        per_cfg_candidates: Dict[str, List[LOPlanCandidate]],\r\n    ) -> tuple[Dict[str, List[LOPlanCandidate]], Dict[str, List[IF2SpurControlRegion]]]:\r\n        \"\"\"\r\n        Use coarse spur analysis to:\r\n          * Reject clearly hopeless LO candidates (margin << 0 dB),\r\n          * Derive IF2 spur-control regions per configuration.\r\n\r\n        Returns:\r\n          (pruned_candidates, spur_control_regions)\r\n          where spur_control_regions is config_id -> list[IF2SpurControlRegion]\r\n        \"\"\"\r\n        cfg = self.cfg\r\n        pruned: Dict[str, List[LOPlanCandidate]] = {}\r\n        control_regions_by_cfg: Dict[str, List[IF2SpurControlRegion]] = {}\r\n\r\n        coarse_min = cfg.grids.coarse_spur_margin_min_db  # negative threshold\r\n        min_survivors_cfg = max(1, cfg.grids.min_lo_candidates_per_rf_after_coarse)\r\n        rf_by_id: Dict[str, RfConfiguration] = {\r\n            rc.config_id: rc for rc in cfg.rf_configurations\r\n        }\r\n\r\n        for config_id, cand_list in per_cfg_candidates.items():\r\n            rf_conf = rf_by_id[config_id]\r\n            survivors: List[LOPlanCandidate] = []\r\n            all_regions: List[IF2SpurControlRegion] = []\r\n            cfg_worst_margin: Optional[float] = None\r\n\r\n            for cand in cand_list:\r\n                regions, worst_margin = coarse_if2_spur_control_regions_for_lo_plan(\r\n                    cfg,\r\n                    rf_conf,\r\n                    cand,\r\n                    self.rf_filter,\r\n                )\r\n\r\n                if worst_margin is not None:\r\n                    if cfg_worst_margin is None or worst_margin < cfg_worst_margin:\r\n                        cfg_worst_margin = worst_margin\r\n\r\n                # If worst_margin is \"very negative\" (e.g. < -10 dB),\r\n                # we consider this LO plan hopeless and drop it.\r\n                if worst_margin is not None and worst_margin < coarse_min:\r\n                    continue\r\n\r\n                survivors.append(cand)\r\n                all_regions.extend(regions)\r\n\r\n            if not survivors:\r\n                # All candidates failed the coarse margin threshold.\r\n                # Keep at least K of them for detailed analysis.\r\n                k = min(len(cand_list), min_survivors_cfg)\r\n                logger.warning(\r\n                    \"Config '%s': all %d LO candidates failed coarse spur \"\r\n                    \"margin threshold (worst margin %.1f dB); keeping the \"\r\n                    \"first %d candidates for detailed analysis.\",\r\n                    config_id,\r\n                    len(cand_list),\r\n                    cfg_worst_margin if cfg_worst_margin is not None else float(\"nan\"),\r\n                    k,\r\n                )\r\n                survivors = cand_list[:k]\r\n            elif len(survivors) < min_survivors_cfg and len(cand_list) > len(survivors):\r\n                # Some survivors, but fewer than requested minimum; top-up with\r\n                # the best of the pruned candidates.\r\n                needed = min_survivors_cfg - len(survivors)\r\n                extra = [c for c in cand_list if c not in survivors][:needed]\r\n                if extra:\r\n                    logger.info(\r\n                        \"Config '%s': coarse pruning left %d survivors (<%d); \"\r\n                        \"adding %d borderline candidates back.\",\r\n                        config_id,\r\n                        len(survivors),\r\n                        min_survivors_cfg,\r\n                        len(extra),\r\n                    )\r\n                    survivors.extend(extra)\r\n\r\n            pruned[config_id] = survivors\r\n            control_regions_by_cfg[config_id] = all_regions\r\n    \r\n\r\n    def _search_lo_plans_for_filter_count(\r\n        self,\r\n        per_cfg_candidates: Dict[str, List[LOPlanCandidate]],\r\n        control_regions_by_cfg: Dict[str, List[IF2SpurControlRegion]],\r\n        n_filters: int,\r\n    ) -> Optional[tuple[List[LOPlanCandidate], IF2BankDesignResult, List[SpurResult], Dict[str, ConfigSpurSummary]]]:\r\n        \"\"\"\r\n        For a fixed IF2 filter count (n_filters), search over LO-plan combinations\r\n        and find a feasible solution that minimizes (n_distinct_LO1, n_distinct_LO2)\r\n        in lexicographic order.\r\n\r\n        Search is bounded by:\r\n            * max_lo_candidates_per_rf   – limits candidates per RF config\r\n            * max_if2_bank_candidates    – limits total (LO-plan, IF2-bank) combos\r\n                                           evaluated at this filter count.\r\n        \"\"\"\r\n        cfg = self.cfg\r\n        rf_confs = cfg.rf_configurations\r\n        ordered_cfg_ids = [rc.config_id for rc in rf_confs]\r\n\r\n        # Limit candidates per config to keep combinatorics sane\r\n        max_per_cfg = max(1, min(4, cfg.grids.max_lo_candidates_per_rf))\r\n        trimmed: Dict[str, List[LOPlanCandidate]] = {}\r\n        for cid in ordered_cfg_ids:\r\n            cands = per_cfg_candidates.get(cid, [])\r\n            trimmed[cid] = cands[:max_per_cfg]\r\n\r\n        max_combos = max(1, cfg.grids.max_if2_bank_candidates)\r\n\r\n        best_lo_plans: Optional[List[LOPlanCandidate]] = None\r\n        best_bank_design: Optional[IF2BankDesignResult] = None\r\n        best_spur_results: List[SpurResult] = []\r\n        best_summaries: Dict[str, ConfigSpurSummary] = {}\r\n        best_score: Optional[tuple[int, int]] = None  # (n_distinct_LO1, n_distinct_LO2)\r\n\r\n        combos_tested = 0\r\n\r\n        def dfs(\r\n            idx: int,\r\n            current: List[LOPlanCandidate],\r\n            used_lo1: set[float],\r\n            used_lo2: set[float],\r\n        ) -> None:\r\n            nonlocal best_lo_plans, best_bank_design, best_spur_results, best_summaries\r\n            nonlocal best_score, combos_tested\r\n\r\n            if combos_tested >= max_combos:\r\n                return\r\n\r\n            # Reached a full assignment: one LO plan per configuration\r\n            if idx == len(ordered_cfg_ids):\r\n                combos_tested += 1\r\n\r\n                # Design IF2 bank for this LO-plan set\r\n                bank_design = design_if2_bank_for_lo_plans(\r\n                    current,\r\n                    cfg.filters.if2_constraints,\r\n                    spur_control_regions=control_regions_by_cfg,\r\n                    target_n_filters=n_filters,\r\n                )\r\n\r\n                # Evaluate spurs for this LO-plan + IF2 bank\r\n                spur_results, summaries = self._evaluate_for_bank_design(\r\n                    current,\r\n                    bank_design,\r\n                )\r\n\r\n                # Check feasibility: all margins (if defined) must be >= 0 dB\r\n                violating: list[str] = []\r\n                for cid, summary in summaries.items():\r\n                    if (\r\n                        summary.worst_in_band_margin_db is not None\r\n                        and summary.worst_in_band_margin_db < 0.0\r\n                    ):\r\n                        violating.append(cid)\r\n                    if (\r\n                        summary.worst_out_band_margin_db is not None\r\n                        and summary.worst_out_band_margin_db < 0.0\r\n                    ):\r\n                        violating.append(cid)\r\n\r\n                if violating:\r\n                    return  # infeasible combination\r\n\r\n                # Feasible: evaluate LO reuse score\r\n                n_lo1 = len(used_lo1)\r\n                n_lo2 = len(used_lo2)\r\n                score = (n_lo1, n_lo2)\r\n                if best_score is None or score < best_score:\r\n                    best_score = score\r\n                    best_lo_plans = list(current)\r\n                    best_bank_design = bank_design\r\n                    best_spur_results = spur_results\r\n                    best_summaries = summaries\r\n                return\r\n\r\n            cfg_id = ordered_cfg_ids[idx]\r\n            cands = trimmed.get(cfg_id, [])\r\n            if not cands:\r\n                return  # no candidates for this config; nothing to do\r\n\r\n            for cand in cands:\r\n                new_used_lo1 = set(used_lo1)\r\n                new_used_lo2 = set(used_lo2)\r\n                new_used_lo1.add(cand.lo1_freq)\r\n                new_used_lo2.add(cand.lo2_freq)\r\n\r\n                # If we already have a feasible solution, use LO reuse score\r\n                # to prune branches that cannot beat it.\r\n                if best_score is not None:\r\n                    partial_score = (len(new_used_lo1), len(new_used_lo2))\r\n                    if partial_score > best_score:\r\n                        continue\r\n\r\n                current.append(cand)\r\n                dfs(idx + 1, current, new_used_lo1, new_used_lo2)\r\n                current.pop()\r\n\r\n                if combos_tested >= max_combos:\r\n                    break\r\n\r\n        dfs(0, [], set(), set())\r\n\r\n        if best_lo_plans is None or best_bank_design is None:\r\n            return None\r\n\r\n        return best_lo_plans, best_bank_design, best_spur_results, best_summaries\r\n\r\n    def _evaluate_for_bank_design(\r\n        self,\r\n        lo_plans: List[LOPlanCandidate],\r\n        bank_design: IF2BankDesignResult,\r\n    ) -> tuple[List[SpurResult], Dict[str, ConfigSpurSummary]]:\r\n        \"\"\"\r\n        Run detailed spur analysis for all configurations for a given IF2 bank design.\r\n        \"\"\"\r\n        cfg = self.cfg\r\n        spur_results: List[SpurResult] = []\r\n        summaries: Dict[str, ConfigSpurSummary] = {}\r\n\r\n        rf_by_id: Dict[str, RfConfiguration] = {rc.config_id: rc for rc in cfg.rf_configurations}\r\n\r\n        if cfg.grids.parallel and len(lo_plans) > 1:\r\n            with ProcessPoolExecutor() as ex:\r\n                futures = {}\r\n                for plan in lo_plans:\r\n                    rf_conf = rf_by_id[plan.config_id]\r\n                    if2_filter = next(\r\n                        f for f in bank_design.bank.filters\r\n                        if f.filter_id == bank_design.config_to_filter_id[plan.config_id]\r\n                    )\r\n                    fut = ex.submit(\r\n                        evaluate_spurs_for_config_and_lo_plan,\r\n                        cfg,\r\n                        rf_conf,\r\n                        plan,\r\n                        if2_filter,\r\n                        self.rf_filter,\r\n                        self._mask_freqs,\r\n                        self._mask_levels,\r\n                    )\r\n                    futures[fut] = plan.config_id\r\n\r\n                for fut in as_completed(futures):\r\n                    config_id = futures[fut]\r\n                    res, summary = fut.result()\r\n                    spur_results.extend(res)\r\n                    summaries[config_id] = summary\r\n        else:\r\n            for plan in lo_plans:\r\n                rf_conf = rf_by_id[plan.config_id]\r\n                if2_filter = next(\r\n                    f for f in bank_design.bank.filters\r\n                    if f.filter_id == bank_design.config_to_filter_id[plan.config_id]\r\n                )\r\n                res, summary = evaluate_spurs_for_config_and_lo_plan(\r\n                    cfg,\r\n                    rf_conf,\r\n                    plan,\r\n                    if2_filter,\r\n                    self.rf_filter,\r\n                    self._mask_freqs,\r\n                    self._mask_levels,\r\n                )\r\n                spur_results.extend(res)\r\n                summaries[plan.config_id] = summary\r\n\r\n        return spur_results, summaries\r\n\r\n    def run(self) -> PlannerResult:\r\n        \"\"\"\r\n        Main planning pipeline:\r\n\r\n        1. Enumerate LO candidates per RF configuration.\r\n        2. Coarse prune LO candidates using fast spur estimates; derive\r\n           IF2 spur-control regions.\r\n        3. Sweep IF2 filter count from min_filters to max_filters:\r\n             * for each filter count, search LO-plan combinations\r\n               (bounded search) to:\r\n                 - design IF2 bank,\r\n                 - run detailed spur analysis,\r\n                 - select a feasible solution that minimizes\r\n                   (n_distinct_LO1, n_distinct_LO2).\r\n        4. Return the first (min-filter-count) feasible solution.\r\n        \"\"\"\r\n        cfg = self.cfg\r\n\r\n        # 1) Enumerate raw LO candidates per configuration\r\n        per_cfg_candidates = self._enumerate_lo_plans()\r\n\r\n        # 2) Coarse pruning + IF2 spur-control regions\r\n        # NOTE: _coarse_prune_lo_candidates may currently return None\r\n        # (placeholder implementation). In that case, fall back to\r\n        # \"no pruning\" and empty spur-control regions.\r\n        coarse_result = self._coarse_prune_lo_candidates(per_cfg_candidates)\r\n        \r\n        if coarse_result is None:\r\n            # No coarse pruning implemented; keep all candidates and use\r\n            # empty control-region lists per config.\r\n            pruned_candidates = per_cfg_candidates\r\n            control_regions_by_cfg = {cfg_id: [] for cfg_id in per_cfg_candidates}\r\n        else:\r\n            pruned_candidates, control_regions_by_cfg = coarse_result\r\n\r\n        min_f = cfg.filters.if2_constraints.min_filters\r\n        max_f = cfg.filters.if2_constraints.max_filters\r\n\r\n        best_lo_plans: Optional[List[LOPlanCandidate]] = None\r\n        best_bank_design: Optional[IF2BankDesignResult] = None\r\n        best_spur_results: List[SpurResult] = []\r\n        best_summaries: Dict[str, ConfigSpurSummary] = {}\r\n\r\n        # 3) Sweep IF2 filter count (lexicographic: min filters first)\r\n        for n_filters in range(min_f, max_f + 1):\r\n            search_res = self._search_lo_plans_for_filter_count(\r\n                pruned_candidates,\r\n                control_regions_by_cfg,\r\n                n_filters,\r\n            )\r\n            if search_res is None:\r\n                continue\r\n\r\n            lo_plans, bank_design, spur_results, summaries = search_res\r\n            best_lo_plans = lo_plans\r\n            best_bank_design = bank_design\r\n            best_spur_results = spur_results\r\n            best_summaries = summaries\r\n            # First n_filters with any feasible solution is the lexicographic\r\n            # optimum in terms of IF2 filter count; within this n_filters,\r\n            # LO retune counts have already been minimized.\r\n            break\r\n\r\n        if best_bank_design is None or best_lo_plans is None:\r\n            raise RuntimeError(\r\n                \"No feasible IF2 bank / LO plan combination found within \"\r\n                \"[min_filters, max_filters] that satisfies spur limits for all configurations.\"\r\n            )\r\n\r\n        return PlannerResult(\r\n            system_config=cfg,\r\n            lo_plans=best_lo_plans,\r\n            if2_bank_design=best_bank_design,\r\n            spur_results=best_spur_results,\r\n            summaries=best_summaries,\r\n        )\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "outputs.py",
              "path": "src\\buc_planner\\outputs.py",
              "size": 10824,
              "content_truncated": false,
              "contents": "# src/buc_planner/outputs.py\r\nfrom __future__ import annotations\r\n\r\nimport json\r\nfrom pathlib import Path\r\nfrom typing import List, Dict\r\n\r\nimport numpy as np\r\n\r\nfrom .config_models import SystemConfig\r\nfrom .if2_bank import IF2BankDesignResult\r\nfrom .los import LOPlanCandidate\r\nfrom .spur_engine import SpurResult, ConfigSpurSummary\r\n\r\n\r\ndef write_lo_plan_policy(\r\n    path: str | Path,\r\n    cfg: SystemConfig,\r\n    lo_plans: List[LOPlanCandidate],\r\n    bank_design: IF2BankDesignResult,\r\n    summaries: Dict[str, ConfigSpurSummary],\r\n) -> None:\r\n    \"\"\"\r\n    JSONL: one record per RF configuration, describing LO1, LO2, IF2 filter, spur summary,\r\n    and key modelling assumptions.\r\n    \"\"\"\r\n    path = Path(path)\r\n    rf_by_id = {rc.config_id: rc for rc in cfg.rf_configurations}\r\n\r\n    with path.open(\"w\") as f:\r\n        for plan in lo_plans:\r\n            summary = summaries.get(plan.config_id)\r\n            rf_conf = rf_by_id[plan.config_id]\r\n\r\n            record = {\r\n                \"config_id\": plan.config_id,\r\n                \"rf_center\": rf_conf.rf_center,\r\n                \"rf_bandwidth\": rf_conf.rf_bandwidth,\r\n                \"lo1_freq\": plan.lo1_freq,\r\n                \"lo1_sign\": plan.sign_combo.sign1,\r\n                \"lo2_freq\": plan.lo2_freq,\r\n                \"lo2_sign\": plan.sign_combo.sign2,\r\n                \"if2_filter_id\": bank_design.config_to_filter_id.get(plan.config_id),\r\n                \"if2_band\": {\r\n                    \"start\": plan.if2_band.start,\r\n                    \"stop\": plan.if2_band.stop,\r\n                },\r\n                \"rf_band\": {\r\n                    \"start\": plan.rf_band.start,\r\n                    \"stop\": plan.rf_band.stop,\r\n                },\r\n                \"spur_summary\": {\r\n                    \"worst_in_band_spur_dbc\": getattr(summary, \"worst_in_band_spur_dbc\", None),\r\n                    \"worst_in_band_margin_db\": getattr(summary, \"worst_in_band_margin_db\", None),\r\n                    \"worst_out_band_spur_dbc\": getattr(summary, \"worst_out_band_spur_dbc\", None),\r\n                    \"worst_out_band_margin_db\": getattr(summary, \"worst_out_band_margin_db\", None),\r\n                } if summary else None,\r\n                \"spur_table_assumptions\": {\r\n                    \"mixer1\": {\r\n                        \"enforce_envelope_completeness\": cfg.mixer1.spur_envelope.enforce_envelope_completeness,\r\n                        \"unspecified_floor_dbc\": cfg.mixer1.spur_envelope.unspecified_floor_dbc,\r\n                    },\r\n                    \"mixer2\": {\r\n                        \"enforce_envelope_completeness\": cfg.mixer2.spur_envelope.enforce_envelope_completeness,\r\n                        \"unspecified_floor_dbc\": cfg.mixer2.spur_envelope.unspecified_floor_dbc,\r\n                    },\r\n                },\r\n                \"spur_limits\": {\r\n                    \"in_band_limit_dbc\": cfg.spur_limits.in_band_limit_dbc,\r\n                    \"out_of_band_limit_dbc\": cfg.spur_limits.out_of_band_limit_dbc,\r\n                    \"mask\": {\r\n                        \"csv_path\": cfg.spur_limits.mask.csv_path,\r\n                        \"apply_in_band\": cfg.spur_limits.mask.apply_in_band,\r\n                        \"apply_out_of_band\": cfg.spur_limits.mask.apply_out_of_band,\r\n                    } if cfg.spur_limits.mask is not None else None,\r\n                    \"out_of_band_range\": {\r\n                        \"start\": cfg.spur_limits.out_of_band_range.start,\r\n                        \"stop\": cfg.spur_limits.out_of_band_range.stop,\r\n                    } if cfg.spur_limits.out_of_band_range is not None else None,\r\n                    \"mask_eval_mode\": cfg.spur_limits.mask_eval_mode,\r\n                },\r\n                \"heuristics\": {\r\n                    \"min_if2_filters\": cfg.filters.if2_constraints.min_filters,\r\n                    \"max_if2_filters\": cfg.filters.if2_constraints.max_filters,\r\n                    \"max_lo_candidates_per_rf\": cfg.grids.max_lo_candidates_per_rf,\r\n                    \"max_if2_bank_candidates\": cfg.grids.max_if2_bank_candidates,\r\n                    \"min_spur_level_considered_dbc\": cfg.grids.min_spur_level_considered_dbc,\r\n                    \"mixer2_if2_focus_margin_hz\": cfg.grids.mixer2_if2_focus_margin_hz,\r\n                },\r\n                \"modelling_assumptions\": {\r\n                    \"lo1_lo2_cross_coupling_modelled\": False,\r\n                    \"if1_grid_segmented\": True,\r\n                    \"planning_grade_only\": True,\r\n                },\r\n            }\r\n            f.write(json.dumps(record) + \"\\n\")\r\n\r\ndef write_spur_ledger(\r\n    path: str | Path,\r\n    spur_results: List[SpurResult],\r\n    top_n_per_config: int = 50,\r\n) -> None:\r\n    \"\"\"\r\n    JSONL spur ledger: top N spurs per configuration by level (worst = largest).\r\n    Includes scalar/mask limit information and in-band/out-of-band flags.\r\n    \"\"\"\r\n    path = Path(path)\r\n    by_cfg: Dict[str, List[SpurResult]] = {}\r\n    for r in spur_results:\r\n        by_cfg.setdefault(r.config_id, []).append(r)\r\n\r\n    with path.open(\"w\") as f:\r\n        for config_id, items in by_cfg.items():\r\n            items_sorted = sorted(items, key=lambda r: r.level_dbc, reverse=True)\r\n            for r in items_sorted[:top_n_per_config]:\r\n                rec = {\r\n                    \"config_id\": r.config_id,\r\n                    \"mixer_name\": r.mixer_name,\r\n                    \"spur_name\": r.spur_name,\r\n                    \"f_start\": r.f_start,\r\n                    \"f_stop\": r.f_stop,\r\n                    \"in_band\": r.in_band,\r\n                    \"out_of_band\": r.out_of_band,\r\n                    \"level_dbc\": r.level_dbc,\r\n                    # Absolute level in dB under the current planning convention\r\n                    # that the desired RF integrated power is 0 dBc == 0 dB.\r\n                    # If a future model introduces non-zero absolute desired RF\r\n                    # power, this field should be updated accordingly.\r\n                    \"level_db_absolute\": r.level_dbc,  # assuming desired RF = 0 dBc\r\n                    \"margin_db\": r.margin_db,\r\n                    \"scalar_limit_dbc\": r.scalar_limit_dbc,\r\n                    \"mask_limit_dbc\": r.mask_limit_dbc,\r\n                    \"scalar_margin_db\": r.scalar_margin_db,\r\n                    \"mask_margin_db\": r.mask_margin_db,\r\n                    \"filter_att_if2_db\": r.filter_att_if2_db,\r\n                    \"filter_att_rf_db\": r.filter_att_rf_db,\r\n                    \"origin_m\": r.origin_m,\r\n                    \"origin_n\": r.origin_n,\r\n                    \"lo_tone_name\": r.lo_tone_name,\r\n                    \"input_band_name\": r.input_band_name,\r\n                    \"used_unspecified_floor\": r.used_unspecified_floor,\r\n                }\r\n                f.write(json.dumps(rec) + \"\\n\")\r\n\t\t\t\t\r\ndef write_if2_bank_description(\r\n    path_json: str | Path,\r\n    csv_dir: str | Path,\r\n    bank_design: IF2BankDesignResult,\r\n    freq_min: float,\r\n    freq_max: float,\r\n    n_points: int = 2001,\r\n) -> None:\r\n    \"\"\"\r\n    Write IF2 bank description and per-filter CSVs.\r\n\r\n    JSON structure:\r\n      {\r\n        \"filters\": [\r\n          {\"filter_id\": ..., \"fc\": ..., \"bw\": ..., \"slope_db_per_decade\": ...},\r\n          ...\r\n        ],\r\n        \"config_to_filter_id\": { \"cfg1\": \"filter_id\", ... }\r\n      }\r\n\r\n    CSVs:\r\n      One file per filter in csv_dir, named \"<filter_id>.csv\",\r\n      with columns: frequency, attenuation_db.\r\n    \"\"\"\r\n    path_json = Path(path_json)\r\n    csv_dir = Path(csv_dir)\r\n    csv_dir.mkdir(parents=True, exist_ok=True)\r\n\r\n    filters_info = []\r\n    for f in bank_design.bank.filters:\r\n        filters_info.append(\r\n            {\r\n                \"filter_id\": f.filter_id,\r\n                \"fc\": f.fc,\r\n                \"bw\": f.bw,\r\n                \"slope_db_per_decade\": f.slope_db_per_decade,\r\n            }\r\n        )\r\n\r\n        freqs = np.linspace(freq_min, freq_max, n_points)\r\n        att = f.attenuation_db(freqs)\r\n        csv_path = csv_dir / f\"{f.filter_id}.csv\"\r\n        data = np.column_stack([freqs, att])\r\n        np.savetxt(csv_path, data, delimiter=\",\", header=\"freq,attenuation_db\", comments=\"\")\r\n\r\n    blob = {\r\n        \"filters\": filters_info,\r\n        \"config_to_filter_id\": bank_design.config_to_filter_id,\r\n    }\r\n    path_json.write_text(json.dumps(blob, indent=2))\r\n\r\ndef write_run_metadata(\r\n    path: str | Path,\r\n    cfg: SystemConfig,\r\n    spur_results: List[SpurResult],\r\n) -> None:\r\n    \"\"\"\r\n    Write a small JSON metadata blob describing modelling options,\r\n    spur-floor usage, and high-level complexity knobs.\r\n\r\n    This is intended as a quick \"header\" for the run.\r\n    \"\"\"\r\n    path = Path(path)\r\n\r\n    n_spurs = len(spur_results)\r\n    n_spurs_with_floor = sum(1 for r in spur_results if r.used_unspecified_floor)\r\n\r\n    metadata = {\r\n        \"description\": cfg.description,\r\n        \"n_rf_configurations\": len(cfg.rf_configurations),\r\n        \"if1_band\": {\"start\": cfg.if1_band.start, \"stop\": cfg.if1_band.stop},\r\n        \"rf_band\": {\"start\": cfg.rf_band.start, \"stop\": cfg.rf_band.stop},\r\n        \"non_inverting_mapping_required\": cfg.non_inverting_mapping_required,\r\n        \"mixer1\": {\r\n            \"name\": cfg.mixer1.name,\r\n            \"enforce_envelope_completeness\": cfg.mixer1.spur_envelope.enforce_envelope_completeness,\r\n            \"unspecified_floor_dbc\": cfg.mixer1.spur_envelope.unspecified_floor_dbc,\r\n        },\r\n        \"mixer2\": {\r\n            \"name\": cfg.mixer2.name,\r\n            \"enforce_envelope_completeness\": cfg.mixer2.spur_envelope.enforce_envelope_completeness,\r\n            \"unspecified_floor_dbc\": cfg.mixer2.spur_envelope.unspecified_floor_dbc,\r\n        },\r\n        \"grids\": {\r\n            \"if1_grid_step_hz\": cfg.grids.if1_grid_step_hz,\r\n            \"spur_integration_step_hz\": cfg.grids.spur_integration_step_hz,\r\n            \"max_if1_harmonic_order\": cfg.grids.max_if1_harmonic_order,\r\n            \"coarse_spur_margin_min_db\": cfg.grids.coarse_spur_margin_min_db,\r\n            \"mixer2_if2_focus_margin_hz\": cfg.grids.mixer2_if2_focus_margin_hz,\r\n            \"use_numba\": cfg.grids.use_numba,\r\n        },\r\n        \"spur_limits\": {\r\n            \"in_band_limit_dbc\": cfg.spur_limits.in_band_limit_dbc,\r\n            \"out_of_band_limit_dbc\": cfg.spur_limits.out_of_band_limit_dbc,\r\n            \"mask_csv\": cfg.spur_limits.mask.csv_path\r\n            if cfg.spur_limits.mask is not None\r\n            else None,\r\n            \"mask_eval_mode\": cfg.spur_limits.mask_eval_mode,\r\n        },\r\n        \"spur_floor_usage\": {\r\n            \"total_spurs\": n_spurs,\r\n            \"spurs_with_unspecified_floor\": n_spurs_with_floor,\r\n        },\r\n        \"modelling_notes\": {\r\n            \"lo1_lo2_cross_coupling_modelled\": False,\r\n            \"planning_grade_only\": True,\r\n            \"wideband_spur_approximation\": True,\r\n        },\r\n    }\r\n\r\n    path.write_text(json.dumps(metadata, indent=2))",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "plotting.py",
              "path": "src\\buc_planner\\plotting.py",
              "size": 1567,
              "content_truncated": false,
              "contents": "# src/buc_planner/plotting.py\r\nfrom __future__ import annotations\r\n\r\nfrom pathlib import Path\r\nfrom typing import Optional, List\r\n\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nfrom .filters import IF2Bank\r\nfrom .config_models import Range\r\nfrom .los import LOPlanCandidate\r\n\r\n\r\ndef plot_if2_bank(\r\n    bank: IF2Bank,\r\n    freq_range: Range,\r\n    out_path: Optional[str | Path] = None,\r\n    lo_plans: Optional[List[LOPlanCandidate]] = None,\r\n) -> None:\r\n    \"\"\"\r\n    Plot overlaid IF2 filter responses over a given frequency range.\r\n\r\n    If lo_plans is provided, desired IF2 bands for each configuration are\r\n    overlaid as translucent spans.\r\n    \"\"\"\r\n    freqs = np.linspace(freq_range.start, freq_range.stop, 2000)\r\n    plt.figure()\r\n    for f in bank.filters:\r\n        att = f.attenuation_db(freqs)\r\n        plt.plot(freqs, att, label=f.filter_id)\r\n\r\n    # Overlay desired IF2 bands\r\n    if lo_plans:\r\n        for i, plan in enumerate(lo_plans):\r\n            band = plan.if2_band\r\n            alpha = 0.08\r\n            plt.axvspan(\r\n                band.start,\r\n                band.stop,\r\n                alpha=alpha,\r\n                linestyle=\"--\",\r\n                label=\"_if2_band\" if i > 0 else \"desired IF2 bands\",\r\n            )\r\n\r\n    plt.xlabel(\"Frequency\")\r\n    plt.ylabel(\"Attenuation (dB)\")\r\n    plt.title(\"IF2 Filter Bank Responses\")\r\n    plt.legend()\r\n    plt.grid(True)\r\n    if out_path:\r\n        out_path = Path(out_path)\r\n        plt.savefig(out_path, dpi=150, bbox_inches=\"tight\")\r\n        plt.close()\r\n    else:\r\n        plt.show()",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "spur_engine.py",
              "path": "src\\buc_planner\\spur_engine.py",
              "size": 40462,
              "content_truncated": false,
              "contents": "# src/buc_planner/spur_engine.py\r\nfrom __future__ import annotations\r\n\r\ntry:\r\n    from numba import njit\r\nexcept Exception:  # noqa: BLE001\r\n    njit = None\r\n\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Optional, Tuple, Dict, Callable\r\n\r\nimport numpy as np\r\n\r\nfrom .config_models import (\r\n    SystemConfig,\r\n    RfConfiguration,\r\n    Range,\r\n    dB,\r\n    dBc,\r\n    Freq,\r\n)\r\nfrom .filters import IF2Filter, RFFilter\r\nfrom .mixers import (\r\n    MixerWidebandSpurBand,\r\n    MixerInputBand,\r\n    resolve_spur_families_for_tones,\r\n    LOTone,\r\n    generate_wideband_spur_band,\r\n)\r\nfrom .los import LOPlanCandidate\r\n\r\nimport logging\r\nlogger = logging.getLogger(__name__)\r\n\r\n\r\ndef prepare_mask(cfg: SystemConfig) -> tuple[Optional[np.ndarray], Optional[np.ndarray]]:\r\n    \"\"\"\r\n    Load and parse the spur mask CSV (if configured) once.\r\n\r\n    Returns:\r\n        (mask_freqs, mask_levels) or (None, None) if no mask is configured.\r\n    \"\"\"\r\n    mask_cfg = cfg.spur_limits.mask\r\n    if not mask_cfg or not mask_cfg.csv_path:\r\n        return None, None\r\n\r\n    data = np.genfromtxt(mask_cfg.csv_path, delimiter=\",\", comments=\"#\")\r\n    if data.ndim == 1:\r\n        data = data.reshape(1, -1)\r\n\r\n    if data.size == 0 or data.shape[1] < 2:\r\n        raise ValueError(\r\n            f\"Spur mask CSV '{mask_cfg.csv_path}' must have at least two columns (freq, level_dbc).\"\r\n        )\r\n\r\n    # Treat leading NaN row as an un-commented header\r\n    if data.shape[0] > 1 and (np.isnan(data[0, 0]) or np.isnan(data[0, 1])):\r\n        data = data[1:, :]\r\n        if data.size == 0 or data.shape[1] < 2:\r\n            raise ValueError(\r\n                f\"Spur mask CSV '{mask_cfg.csv_path}' has only a header and no data rows.\"\r\n            )\r\n\r\n    mask_freqs = data[:, 0].astype(float)\r\n    mask_levels = data[:, 1].astype(float)\r\n    idx = np.argsort(mask_freqs)\r\n    return mask_freqs[idx], mask_levels[idx]\r\n\r\n\r\n@dataclass\r\nclass SpurResult:\r\n    \"\"\"\r\n    Single spur (wideband or narrowband) at the RF output.\r\n\r\n    All levels are expressed in dBc relative to the desired RF integrated power.\r\n    The current planning-grade model assumes that the desired RF integrated\r\n    power is 0 dBc (i.e. same reference as IF1), so level_dbc is also an\r\n    absolute dB value under that convention. If a non-zero desired RF gain\r\n    G_chain,des is introduced in the future, the mapping to absolute dB should\r\n    be adjusted in the output layer.\r\n    \"\"\"\r\n    config_id: str\r\n    mixer_name: str\r\n    spur_name: str\r\n    f_start: Freq\r\n    f_stop: Freq\r\n    in_band: bool\r\n    out_of_band: bool\r\n    level_dbc: dBc\r\n    margin_db: Optional[dB]\r\n    filter_att_if2_db: dB\r\n    filter_att_rf_db: dB\r\n    origin_m: int\r\n    origin_n: int\r\n    lo_tone_name: str\r\n    input_band_name: str\r\n    used_unspecified_floor: bool = False\r\n    # Limit bookkeeping\r\n    scalar_limit_dbc: Optional[dBc] = None\r\n    mask_limit_dbc: Optional[dBc] = None\r\n    scalar_margin_db: Optional[dB] = None\r\n    mask_margin_db: Optional[dB] = None\r\n\t\r\n\t\r\n@dataclass\r\nclass IF2SpurControlRegion:\r\n    \"\"\"\r\n    Coarse region at the Mixer2 IF (IF2) node where we need\r\n    additional attenuation from the IF2 BPF bank.\r\n\r\n    required_rejection_db is \"extra attenuation needed at IF2\"\r\n    so that the spur would just meet the scalar spur limit,\r\n    based on a simple no-filter coarse model.\r\n    \"\"\"\r\n    config_id: str\r\n    kind: str               # \"in_band\" or \"out_of_band\"\r\n    freq_start: Freq\r\n    freq_stop: Freq\r\n    required_rejection_db: dB\r\n    spur_name: str\r\n    mixer_name: str\r\n\r\n\r\n@dataclass\r\nclass ConfigSpurSummary:\r\n    config_id: str\r\n    worst_in_band_spur_dbc: Optional[dBc]\r\n    worst_in_band_margin_db: Optional[dB]\r\n    worst_out_band_spur_dbc: Optional[dBc]\r\n    worst_out_band_margin_db: Optional[dB]\r\n\r\n\r\ndef _segment_range(r: Range, step_hz: float) -> List[Range]:\r\n    \"\"\"\r\n    Split a Range into contiguous sub-ranges with max width ≈ step_hz.\r\n\r\n    If step_hz <= 0 or larger than the range width, return [r] unchanged.\r\n    \"\"\"\r\n    if step_hz <= 0 or r.width <= 0 or step_hz >= r.width:\r\n        return [r]\r\n\r\n    n_seg = int(np.ceil(r.width / step_hz))\r\n    edges = np.linspace(r.start, r.stop, n_seg + 1)\r\n    segments: List[Range] = []\r\n    for i in range(n_seg):\r\n        segments.append(Range(start=float(edges[i]), stop=float(edges[i + 1])))\r\n    return segments\r\n\r\n\r\ndef _build_if1_input_bands(\r\n    cfg: SystemConfig,\r\n    rf_conf: RfConfiguration,\r\n) -> List[MixerInputBand]:\r\n    \"\"\"\r\n    Fundamental + harmonics, clipped by Mixer1 IF range, then segmented along\r\n    an IF1 frequency grid (spec 9.5).\r\n\r\n    Canonical semantics for IF1 harmonics:\r\n\r\n      * cfg.if1_harmonics_dbc[k] is interpreted as the **integrated power over\r\n        the k-th harmonic band derived from the effective IF1 band for this\r\n        configuration** (rf_conf.if1_subband or cfg.if1_band), before clipping\r\n        by Mixer1 IF range.\r\n\r\n      * This may differ numerically from examples that use a fixed global\r\n        950–2450 MHz band for all configs, but is the chosen planning-grade\r\n        convention for this tool and should be used when deriving harmonic\r\n        levels from measurements.\r\n\r\n    Power semantics (aligned with spec):\r\n\r\n      * Fundamental:\r\n          - The IF1 reference power (0 dBc) is defined as the integrated power\r\n            over the full configured IF1 band cfg.if1_band.\r\n          - We model flat PSD over this band.\r\n          - When we segment the (possibly smaller) effective IF1 band for this\r\n            configuration, each segment is assigned integrated power\r\n                0 dBc + 10*log10(BW_seg / BW_IF1_total)\r\n            so that the sum of all segments over the full IF1 band would be\r\n            0 dBc.\r\n\r\n      * Harmonic k:\r\n          - cfg.if1_harmonics_dbc[k] is interpreted as the integrated power\r\n            over the *entire* harmonic band BEFORE clipping:\r\n                [k * IF1_eff_start, k * IF1_eff_stop],\r\n            where IF1_eff_start/stop come from the effective IF1 band for this\r\n            configuration (rf_conf.if1_subband or cfg.if1_band).\r\n            This is slightly different from the numeric example in the spec\r\n            (which uses the global 950–2450 MHz band), but is an equivalent\r\n            planning-grade model tied to the actually used IF1 band.\r\n          - We again assume flat PSD over that harmonic band.\r\n          - After clipping by Mixer1 IF range and segmenting, each segment\r\n            gets integrated power:\r\n                L_harm,k + 10*log10(BW_seg / BW_harm_full)\r\n            where BW_harm_full is the width of the un-clipped harmonic band.\r\n          - Portions of the harmonic band outside Mixer1 IF range simply do\r\n            not generate spurs.\r\n\r\n    Uses:\r\n      * cfg.grids.if1_grid_step_hz as segment width.\r\n      * cfg.grids.max_if1_harmonic_order to truncate harmonics.\r\n      * cfg.if1_harmonics_dbc for harmonic levels.\r\n    \"\"\"\r\n    bands: List[MixerInputBand] = []\r\n\r\n    # Effective IF1 band for this configuration (may be a sub-band)\r\n    if1_band_cfg = rf_conf.if1_subband or cfg.if1_band\r\n\r\n    # Clip by Mixer1 IF range\r\n    m1_if_range = cfg.mixer1.ranges.if_range\r\n    base_band = if1_band_cfg.intersect(m1_if_range)\r\n    if base_band is None or base_band.width <= 0:\r\n        return bands\r\n\r\n    step = cfg.grids.if1_grid_step_hz\r\n    base_segments = _segment_range(base_band, step)\r\n\r\n    # --- Fundamental segments (0 dBc integrated over full cfg.if1_band) ---\r\n    if1_ref_band = cfg.if1_band\r\n    bw_if1_total = max(if1_ref_band.width, 1e-30)  # protect log10\r\n\r\n    for idx, seg in enumerate(base_segments):\r\n        bw_seg = max(seg.width, 1e-30)\r\n        # segment integrated power relative to IF1 reference\r\n        level_seg_dbc = 10.0 * np.log10(bw_seg / bw_if1_total)\r\n        bands.append(\r\n            MixerInputBand(\r\n                name=f\"IF1_fund_seg{idx}\",\r\n                f_start=seg.start,\r\n                f_stop=seg.stop,\r\n                level_dbc_integrated=level_seg_dbc,\r\n            )\r\n        )\r\n\r\n    # --- Harmonics ---\r\n    max_h = cfg.grids.max_if1_harmonic_order\r\n\r\n    for order, lvl in cfg.if1_harmonics_dbc.items():\r\n        if order <= 1 or order > max_h:\r\n            continue\r\n\r\n        # Full harmonic band BEFORE clipping, based on the effective IF1 band\r\n        harm_full = Range(\r\n            start=order * if1_band_cfg.start,\r\n            stop=order * if1_band_cfg.stop,\r\n        )\r\n        bw_harm_full = max(harm_full.width, 1e-30)\r\n\r\n        # Clip by Mixer1 IF range (spec: clipping happens before spur generation)\r\n        harm_clipped = harm_full.intersect(m1_if_range)\r\n        if harm_clipped is None or harm_clipped.width <= 0:\r\n            continue\r\n\r\n        harm_step = step * order if step > 0 else 0.0\r\n        harm_segments = _segment_range(harm_clipped, harm_step)\r\n\r\n        for idx, seg in enumerate(harm_segments):\r\n            bw_seg = max(seg.width, 1e-30)\r\n            # Integrated power of this segment relative to IF1 fundamental:\r\n            # L_harm,k (whole band) + 10*log10(BW_seg / BW_harm_full)\r\n            level_seg_dbc = lvl + 10.0 * np.log10(bw_seg / bw_harm_full)\r\n            bands.append(\r\n                MixerInputBand(\r\n                    name=f\"IF1_h{order}_seg{idx}\",\r\n                    f_start=seg.start,\r\n                    f_stop=seg.stop,\r\n                    level_dbc_integrated=level_seg_dbc,\r\n                )\r\n            )\r\n\r\n    return bands\r\n\r\n\r\ndef _build_lo_tones_for_synth(\r\n    lo_freq: Freq,\r\n    synth_cfg,\r\n) -> List[LOTone]:\r\n    tones: List[LOTone] = [LOTone(name=\"fundamental\", freq=lo_freq, level_dbc=0.0)]\r\n    for h in synth_cfg.harmonics:\r\n        tones.append(\r\n            LOTone(\r\n                name=f\"harmonic_{h.order}\",\r\n                freq=h.order * lo_freq,\r\n                level_dbc=h.level_dbc,\r\n            )\r\n        )\r\n    if synth_cfg.pfd_frequency and synth_cfg.pll_spurs:\r\n        for spur in synth_cfg.pll_spurs:\r\n            df = spur.offset_multiple * synth_cfg.pfd_frequency\r\n            tones.append(\r\n                LOTone(\r\n                    name=f\"pll_spur_+{spur.offset_multiple}\",\r\n                    freq=lo_freq + df,\r\n                    level_dbc=spur.level_dbc,\r\n                )\r\n            )\r\n            tones.append(\r\n                LOTone(\r\n                    name=f\"pll_spur_-{spur.offset_multiple}\",\r\n                    freq=lo_freq - df,\r\n                    level_dbc=spur.level_dbc,\r\n                )\r\n            )\r\n    return tones\r\n\t\r\n\t\r\ndef coarse_if2_spur_control_regions_for_lo_plan(\r\n    cfg: SystemConfig,\r\n    rf_conf: RfConfiguration,\r\n    lo_plan: LOPlanCandidate,\r\n    rf_filter: RFFilter,\r\n) -> tuple[list[IF2SpurControlRegion], Optional[dB]]:\r\n    \"\"\"\r\n    Coarse pass used for:\r\n      * deriving IF2 spur-control regions, and\r\n      * early pruning of hopeless LO plans.\r\n\r\n    Model:\r\n      * Only Mixer1 wideband spurs.\r\n      * These spurs are mapped through Mixer2's **fundamental** path only.\r\n      * Mixer2's own spur families (from its spur table, LO2 harmonics/PLLs)\r\n        are ignored at this stage and are handled only in the full spur pass.\r\n      * Ignore IF2 filter completely.\r\n      * Map surviving Mixer1 spurs through Mixer2 fundamental path\r\n        into RF to classify in-band / out-of-band.\r\n      * Compare spur level to scalar limits (mask ignored for speed).\r\n      * For any spur above its limit (negative margin), record an\r\n        IF2 region with required_rejection_db at IF2 equal to -margin.\r\n      * Return:\r\n          (regions, worst_margin_dB)\r\n        where worst_margin_dB is the minimum scalar margin across\r\n        all considered spurs (negative => violation).\r\n\r\n    NOTE:\r\n      Frequency-dependent spur masks (if configured) are intentionally\r\n      ignored in this coarse pass for performance. Masks are applied only\r\n      in the detailed spur evaluation.\r\n    \"\"\"\r\n    def _is_desired_family(mixer_cfg, spur_spec) -> bool:\r\n        return (\r\n            spur_spec.entry.m == mixer_cfg.desired_m\r\n            and spur_spec.entry.n == mixer_cfg.desired_n\r\n        )\r\n        \r\n    grids = cfg.grids\r\n    regions: list[IF2SpurControlRegion] = []\r\n    worst_margin: Optional[dB] = None\r\n\r\n    in_band_limit = cfg.spur_limits.in_band_limit_dbc\r\n    oob_limit = cfg.spur_limits.out_of_band_limit_dbc\r\n    oob_range = cfg.spur_limits.out_of_band_range\r\n    rf_band_global = cfg.rf_band\r\n\r\n    # Per-configuration in-band RF channel\r\n    rf_inband = Range(\r\n        start=rf_conf.rf_center - 0.5 * rf_conf.rf_bandwidth,\r\n        stop=rf_conf.rf_center + 0.5 * rf_conf.rf_bandwidth,\r\n    )\r\n\r\n    # 1) Mixer1 input bands (same helper as detailed path)\r\n    m1_bands = _build_if1_input_bands(cfg, rf_conf)\r\n    if not m1_bands:\r\n        return regions, None\r\n\r\n    # 2) Mixer1 spur families (all LO1 tones)\r\n    m1_lo_tones = _build_lo_tones_for_synth(lo_plan.lo1_freq, cfg.lo1)\r\n    m1_spur_specs = resolve_spur_families_for_tones(cfg.mixer1, m1_lo_tones)\r\n    m1_spur_specs = [\r\n        spec for spec in m1_spur_specs\r\n        if not _is_desired_family(cfg.mixer1, spec)\r\n    ]\r\n\r\n    m2_if_range = cfg.mixer2.ranges.if_range\r\n\r\n    # Helper: classify center -> in/out band (no mask)\r\n    def classify_rf_center(f_center: float) -> tuple[bool, bool]:\r\n        in_band = rf_inband.contains(f_center)\r\n        if oob_range is None:\r\n            out_band = not in_band\r\n        else:\r\n            out_band = oob_range.contains(f_center) and not in_band\r\n        return in_band, out_band\r\n\r\n    # 3) For each Mixer1 spur, see what happens if it enters Mixer2 as IF\r\n    sign2 = lo_plan.sign_combo.sign2\r\n    lo2_freq = lo_plan.lo2_freq\r\n\r\n    for input_band in m1_bands:\r\n        for spec in m1_spur_specs:\r\n            spur = generate_wideband_spur_band(\r\n                input_band=input_band,\r\n                spur_spec=spec,\r\n                min_level_considered_dbc=grids.min_spur_level_considered_dbc,\r\n            )\r\n            if spur is None:\r\n                continue\r\n\r\n            # Spur at Mixer1 RF node, now see intersection with Mixer2 IF range\r\n            spur_if_range = Range(start=spur.f_start, stop=spur.f_stop)\r\n            inter = spur_if_range.intersect(m2_if_range)\r\n            if inter is None or inter.width <= 0:\r\n                continue\r\n\r\n            # Use intersection as \"IF2 spur band\"\r\n            if2_spur_band = inter\r\n            if if2_spur_band.width <= 0:\r\n                continue\r\n\r\n            # Map IF2 spur band through Mixer2 fundamental path\r\n            if sign2 > 0:\r\n                rf_lo = lo2_freq + sign2 * if2_spur_band.start\r\n                rf_hi = lo2_freq + sign2 * if2_spur_band.stop\r\n            else:\r\n                rf_lo = lo2_freq - if2_spur_band.stop\r\n                rf_hi = lo2_freq - if2_spur_band.start\r\n\r\n            rf_center = 0.5 * (rf_lo + rf_hi)\r\n            in_band, out_band = classify_rf_center(rf_center)\r\n            if not in_band and not out_band:\r\n                continue\r\n\r\n            # Spur level at RF *before* any IF2/RF filter:\r\n            level_before = spur.spur_level_rel_if1_dbc\r\n\r\n            # RF BPF coarse attenuation at center (cheap)\r\n            a_rf = float(rf_filter.attenuation_db(np.array([rf_center]))[0])\r\n            level_after_rf = level_before - a_rf\r\n\r\n            # Pick scalar limit\r\n            scalar_limit: Optional[dBc] = None\r\n            if in_band and in_band_limit is not None:\r\n                scalar_limit = in_band_limit\r\n            elif out_band and oob_limit is not None:\r\n                scalar_limit = oob_limit\r\n            if scalar_limit is None:\r\n                continue\r\n\r\n            margin = scalar_limit - level_after_rf  # positive = OK, negative = violation\r\n\r\n            if worst_margin is None or margin < worst_margin:\r\n                worst_margin = margin\r\n\r\n            # Only record spur-control regions for actual violations\r\n            if margin < 0.0:\r\n                regions.append(\r\n                    IF2SpurControlRegion(\r\n                        config_id=rf_conf.config_id,\r\n                        kind=\"in_band\" if in_band else \"out_of_band\",\r\n                        freq_start=if2_spur_band.start,\r\n                        freq_stop=if2_spur_band.stop,\r\n                        required_rejection_db=-margin,  # extra attenuation needed\r\n                        spur_name=spur.name,\r\n                        mixer_name=spur.mixer_name,\r\n                    )\r\n                )\r\n\r\n    return regions, worst_margin\r\n\r\n\r\nif njit is not None:\r\n    @njit(cache=True, fastmath=True)  # type: ignore[misc]\r\n    def _integrate_spur_linear_numba(\r\n        spur_linear_before: float,\r\n        total_att_db: np.ndarray,\r\n    ) -> float:\r\n        gains_linear = 10.0 ** (-total_att_db / 10.0)\r\n        avg_gain = gains_linear.mean()\r\n        return spur_linear_before * avg_gain\r\nelse:\r\n    _integrate_spur_linear_numba = None\r\n\t\r\ndef _integrate_spur_band_through_filters(\r\n    spur_band: MixerWidebandSpurBand,\r\n    if2_filter: IF2Filter,\r\n    rf_filter: RFFilter,\r\n    cfg: SystemConfig,\r\n    apply_if2_filter: bool = True,\r\n) -> Tuple[dBc, dB, dB]:\r\n    \"\"\"\r\n    Integrate a wideband spur over its band with IF2 and RF filter attenuations.\r\n\r\n    Modelling details:\r\n\r\n      * The spur is treated as having flat PSD across [f_start, f_stop].\r\n      * The pre-filter *integrated* spur level is spur_band.spur_level_rel_if1_dbc\r\n        (relative to the IF1 reference integrated power).\r\n      * We sample attenuation A_total(f) in dB on a grid across the spur band,\r\n        convert to linear gain^2 G2(f) = 10^(-A_total/10), and then use the\r\n        *average* G2 over the band:\r\n            P_after = P_before * mean(G2(f))\r\n\r\n        This is equivalent to performing an explicit ∑ PSD * G2(f) * Δf\r\n        integration under the flat-PSD assumption, but is cheaper to compute.\r\n\r\n    Desired RF integrated power is taken as 0 dBc, so the returned spur level\r\n    is directly in dBc relative to the desired RF product.\r\n    \"\"\"\r\n    f_start, f_stop = spur_band.f_start, spur_band.f_stop\r\n    if f_stop <= f_start:\r\n        return -300.0, 0.0, 0.0\r\n\r\n    span = f_stop - f_start\r\n    df = cfg.grids.spur_integration_step_hz\r\n\r\n    # Defensive: if df is <= 0 or larger than the band, fall back\r\n    # to a single-step integration over the entire band.\r\n    if df <= 0.0 or df >= span:\r\n        n_steps = 1\r\n    else:\r\n        n_steps = max(int(np.ceil(span / df)), 1)\r\n\r\n    freqs = f_start + (np.arange(n_steps) + 0.5) * (f_stop - f_start) / n_steps\r\n\r\n    if apply_if2_filter:\r\n        a_if2_db = if2_filter.attenuation_db(freqs)\r\n    else:\r\n        a_if2_db = np.zeros_like(freqs)\r\n    a_rf_db = rf_filter.attenuation_db(freqs)\r\n    total_att_db = a_if2_db + a_rf_db\r\n\r\n    spur_linear_before = 10.0 ** (spur_band.spur_level_rel_if1_dbc / 10.0)\r\n\r\n    if cfg.grids.use_numba and _integrate_spur_linear_numba is not None:\r\n        spur_linear_after = _integrate_spur_linear_numba(\r\n            float(spur_linear_before),\r\n            total_att_db.astype(np.float64),\r\n        )\r\n    else:\r\n        gains_linear = 10.0 ** (-total_att_db / 10.0)\r\n        avg_gain = gains_linear.mean()\r\n        spur_linear_after = spur_linear_before * avg_gain\r\n\r\n    spur_level_after_dbc = 10.0 * np.log10(spur_linear_after + 1e-30)\r\n\r\n    if2_att_db_equiv = float(a_if2_db.mean())\r\n    rf_att_db_equiv = float(a_rf_db.mean())\r\n    return spur_level_after_dbc, if2_att_db_equiv, rf_att_db_equiv\r\n\r\n\r\ndef classify_spur_band_in_out(\r\n    spur_band: MixerWidebandSpurBand,\r\n    rf_band: Range,\r\n    oob_range: Optional[Range],\r\n) -> Tuple[bool, bool]:\r\n    \"\"\"\r\n    Classify a spur band as in-band / out-of-band based on its **center\r\n    frequency** only.\r\n\r\n    This is a planning-grade approximation: very wide spur bands that partly\r\n    overlap the RF channel may be under- or over-classified. The spur *level*\r\n    itself still comes from an integrated model; only the in/out flags are\r\n    center-based.\r\n    \"\"\"\r\n    center = spur_band.center_freq\r\n    in_band = rf_band.contains(center)\r\n    if oob_range is None:\r\n        out_band = not in_band\r\n    else:\r\n        out_band = oob_range.contains(center) and not in_band\r\n    return in_band, out_band\r\n\r\n\r\ndef evaluate_spurs_for_config_and_lo_plan(\r\n    cfg: SystemConfig,\r\n    rf_conf: RfConfiguration,\r\n    lo_plan: LOPlanCandidate,\r\n    if2_filter: IF2Filter,\r\n    rf_filter: RFFilter,\r\n    mask_freqs: Optional[np.ndarray] = None,\r\n    mask_levels: Optional[np.ndarray] = None,\r\n) -> Tuple[List[SpurResult], ConfigSpurSummary]:\r\n    \"\"\"\r\n    Full spur evaluation for a single RF configuration and LO plan.\r\n\r\n    Wideband spurs:\r\n      * Mixer1: IF1 fundamentals + harmonics → IF2, then through IF2 & into Mixer2.\r\n      * Mixer2: spurs from IF2 desired band + cascaded Mixer1 spurs +\r\n                Mixer1 isolation contributions.\r\n\r\n    Narrowband spurs:\r\n      * Mixer2 LO→RF and IF→RF isolation, treated as tones (including LO harmonics/PLLs).\r\n    \"\"\"\r\n    # Helper: identify the (m, n) of the desired mixer product so we can\r\n    # exclude it from the spur lists.\r\n    def _is_desired_family(mixer_cfg, spur_spec) -> bool:\r\n        return (\r\n            spur_spec.entry.m == mixer_cfg.desired_m\r\n            and spur_spec.entry.n == mixer_cfg.desired_n\r\n        )\r\n    \r\n    results: List[SpurResult] = []\r\n    grids = cfg.grids\r\n\r\n    # Spur mask (if provided)\r\n    mask_cfg = cfg.spur_limits.mask\r\n    mask_freqs_local = mask_freqs\r\n    mask_levels_local = mask_levels\r\n    \r\n    # Fallback: load on demand if not provided (e.g. older callers)\r\n    if mask_cfg and mask_cfg.csv_path and (\r\n        mask_freqs_local is None or mask_levels_local is None\r\n    ):\r\n        mask_freqs_local, mask_levels_local = prepare_mask(cfg)\r\n\r\n    if not mask_cfg or not mask_cfg.csv_path:\r\n        mask_freqs_local = None\r\n        mask_levels_local = None\r\n\r\n    def interpolate_mask_level_center(freq: float) -> Optional[float]:\r\n        if mask_freqs_local is None or mask_levels_local is None:\r\n            return None\r\n        lo_f = mask_freqs_local[0]\r\n        hi_f = mask_freqs_local[-1]\r\n        f_clamped = float(np.clip(freq, lo_f, hi_f))\r\n        return float(np.interp(f_clamped, mask_freqs_local, mask_levels_local))\r\n\r\n    def interpolate_mask_level_worst_case(f_start: float, f_stop: float) -> Optional[float]:\r\n        if mask_freqs_local is None or mask_levels_local is None:\r\n            return None\r\n        lo_f = mask_freqs_local[0]\r\n        hi_f = mask_freqs_local[-1]\r\n        n = 16\r\n        freqs = np.linspace(f_start, f_stop, n)\r\n        freqs = np.clip(freqs, lo_f, hi_f)\r\n        levels = np.interp(freqs, mask_freqs_local, mask_levels_local)\r\n        return float(levels.min())\r\n\r\n    mask_eval_mode = cfg.spur_limits.mask_eval_mode.lower()\r\n    if mask_eval_mode not in (\"center\", \"worst_case\"):\r\n        mask_eval_mode = \"center\"\r\n\r\n    # 1) Mixer1 input bands (IF1 fundamental + harmonics, clipped by Mixer1 IF)\r\n    m1_bands = _build_if1_input_bands(cfg, rf_conf)\r\n    m1_lo_tones = _build_lo_tones_for_synth(lo_plan.lo1_freq, cfg.lo1)\r\n    m1_spur_specs = resolve_spur_families_for_tones(cfg.mixer1, m1_lo_tones)\r\n    \r\n    # Drop the desired (m, n) family for Mixer1 so the fundamental\r\n    # IF1->IF2 path is not treated as a spur.\r\n    m1_spur_specs = [\r\n        spec for spec in m1_spur_specs\r\n        if not _is_desired_family(cfg.mixer1, spec)\r\n    ]\r\n\r\n    m1_spurs: List[MixerWidebandSpurBand] = []\r\n    for in_band in m1_bands:\r\n        for spec in m1_spur_specs:\r\n            spur = generate_wideband_spur_band(\r\n                input_band=in_band,\r\n                spur_spec=spec,\r\n                min_level_considered_dbc=grids.min_spur_level_considered_dbc,\r\n            )\r\n            if spur is not None:\r\n                m1_spurs.append(spur)\r\n\r\n    # 2) Mixer2 input bands\r\n    if2_band = lo_plan.if2_band\r\n    m2_if_range = cfg.mixer2.ranges.if_range\r\n\r\n    # Optional focus region: desired IF2 ± margin\r\n    focus_margin = grids.mixer2_if2_focus_margin_hz\r\n    if focus_margin > 0.0:\r\n        focus_band = Range(\r\n            start=if2_band.start - focus_margin,\r\n            stop=if2_band.stop + focus_margin,\r\n        )\r\n    else:\r\n        focus_band = None\r\n\r\n    def focus_clip(r: Range) -> Optional[Range]:\r\n        if focus_band is None:\r\n            return r\r\n        return r.intersect(focus_band)\r\n\r\n    # Desired IF2 band as mixer2 input (reference 0 dBc)\r\n    base_if2 = if2_band.intersect(m2_if_range)\r\n    if base_if2 is None or base_if2.width <= 0:\r\n        m2_input_bands: List[MixerInputBand] = []\r\n    else:\r\n        base_if2 = focus_clip(base_if2) or base_if2\r\n        m2_input_bands = [\r\n            MixerInputBand(\r\n                name=\"IF2_desired_band\",\r\n                f_start=base_if2.start,\r\n                f_stop=base_if2.stop,\r\n                level_dbc_integrated=0.0,\r\n            )\r\n        ]\r\n\r\n    # Cascaded Mixer1 spurs that survive IF2 and land in Mixer2 IF range\r\n    for spur in m1_spurs:\r\n        spur_range = Range(start=spur.f_start, stop=spur.f_stop)\r\n        inter = spur_range.intersect(m2_if_range)\r\n        if inter is None or inter.width <= 0:\r\n            continue\r\n        inter = focus_clip(inter) or inter\r\n        if inter.width <= 0:\r\n            continue\r\n\r\n        df = grids.spur_integration_step_hz\r\n        n_steps = max(int(np.ceil(inter.width / df)), 1)\r\n        freqs = inter.start + (np.arange(n_steps) + 0.5) * inter.width / n_steps\r\n        a_if2 = if2_filter.attenuation_db(freqs)\r\n        a_if2_avg = float(a_if2.mean())\r\n\r\n        new_level = spur.spur_level_rel_if1_dbc - a_if2_avg\r\n        if new_level < grids.min_spur_level_considered_dbc:\r\n            continue\r\n\r\n        m2_input_bands.append(\r\n            MixerInputBand(\r\n                name=f\"M1spur[{spur.name}]_into_M2\",\r\n                f_start=inter.start,\r\n                f_stop=inter.stop,\r\n                level_dbc_integrated=new_level,\r\n            )\r\n        )\r\n\r\n    # 2a) Mixer1 isolation contributions into Mixer2\r\n    # LO1 -> IF2 leakage: each LO1 tone leaks, sees IF2 filter, then is an IF2 tone into Mixer2\r\n    if cfg.mixer1.isolation.lo_to_rf_dbc is not None:\r\n        for tone in m1_lo_tones:\r\n            f0 = tone.freq\r\n            if not m2_if_range.contains(f0):\r\n                continue\r\n            a_if2 = float(if2_filter.attenuation_db(np.array([f0]))[0])\r\n            level_after_if2 = cfg.mixer1.isolation.lo_to_rf_dbc + tone.level_dbc - a_if2\r\n            if level_after_if2 < grids.min_spur_level_considered_dbc:\r\n                continue\r\n            bw = max(grids.spur_integration_step_hz, 1.0)\r\n            band = Range(start=f0 - 0.5 * bw, stop=f0 + 0.5 * bw)\r\n            band = focus_clip(band) or band\r\n            if band.width <= 0:\r\n                continue\r\n            m2_input_bands.append(\r\n                MixerInputBand(\r\n                    name=f\"M1_LO_leak_{tone.name}\",\r\n                    f_start=band.start,\r\n                    f_stop=band.stop,\r\n                    level_dbc_integrated=level_after_if2,\r\n                )\r\n            )\r\n\r\n    # IF1 -> IF2 leakage from Mixer1: approximate as a wideband leak of the IF1 band\r\n    if cfg.mixer1.isolation.if_to_rf_dbc is not None:\r\n        if1_band = rf_conf.if1_subband or cfg.if1_band\r\n        leak_band = if1_band.intersect(m2_if_range)\r\n        if leak_band is not None and leak_band.width > 0:\r\n            leak_band = focus_clip(leak_band) or leak_band\r\n            if leak_band.width > 0:\r\n                df = grids.spur_integration_step_hz\r\n                n_steps = max(int(np.ceil(leak_band.width / df)), 1)\r\n                freqs = leak_band.start + (np.arange(n_steps) + 0.5) * leak_band.width / n_steps\r\n                a_if2 = if2_filter.attenuation_db(freqs)\r\n                a_if2_avg = float(a_if2.mean())\r\n                level_after_if2 = cfg.mixer1.isolation.if_to_rf_dbc - a_if2_avg\r\n                if level_after_if2 >= grids.min_spur_level_considered_dbc:\r\n                    m2_input_bands.append(\r\n                        MixerInputBand(\r\n                            name=\"M1_IF_leak_wideband\",\r\n                            f_start=leak_band.start,\r\n                            f_stop=leak_band.stop,\r\n                            level_dbc_integrated=level_after_if2,\r\n                        )\r\n                    )\r\n\r\n    # 3) Mixer2 spur families\r\n    m2_lo_tones = _build_lo_tones_for_synth(lo_plan.lo2_freq, cfg.lo2)\r\n    m2_spur_specs = resolve_spur_families_for_tones(cfg.mixer2, m2_lo_tones)\r\n    \r\n    # Drop the desired (m, n) family for Mixer2 so that the desired\r\n    # IF2->RF product is not treated as a spur and never checked against\r\n    # in-band / out-of-band spur limits.\r\n    m2_spur_specs = [\r\n        spec for spec in m2_spur_specs\r\n        if not _is_desired_family(cfg.mixer2, spec)\r\n    ]\r\n\r\n    m2_spurs: List[MixerWidebandSpurBand] = []\r\n    for in_band in m2_input_bands:\r\n        for spec in m2_spur_specs:\r\n            spur = generate_wideband_spur_band(\r\n                input_band=in_band,\r\n                spur_spec=spec,\r\n                min_level_considered_dbc=grids.min_spur_level_considered_dbc,\r\n            )\r\n            if spur is not None:\r\n                m2_spurs.append(spur)\r\n\r\n    # In-band is the RF *configuration* channel; out-of-band is defined\r\n    # by spur_limits.out_of_band_range (if provided).\r\n    rf_inband = Range(\r\n        start=rf_conf.rf_center - 0.5 * rf_conf.rf_bandwidth,\r\n        stop=rf_conf.rf_center + 0.5 * rf_conf.rf_bandwidth,\r\n    )\r\n    oob_range = cfg.spur_limits.out_of_band_range\r\n\r\n    in_band_limit = cfg.spur_limits.in_band_limit_dbc\r\n    oob_limit = cfg.spur_limits.out_of_band_limit_dbc\r\n\r\n    worst_in_dbc: Optional[dBc] = None\r\n    worst_in_margin: Optional[dB] = None\r\n    worst_oob_dbc: Optional[dBc] = None\r\n    worst_oob_margin: Optional[dB] = None\r\n\r\n    def update_worst(\r\n        level_dbc: dBc,\r\n        in_band: bool,\r\n        out_band: bool,\r\n        margin: Optional[dB],\r\n    ):\r\n        nonlocal worst_in_dbc, worst_in_margin, worst_oob_dbc, worst_oob_margin\r\n        if margin is None:\r\n            return\r\n\r\n        # We care about the spur with the *smallest* margin (most negative),\r\n        # not the largest absolute spur level.\r\n        if in_band:\r\n            if worst_in_margin is None or margin < worst_in_margin:\r\n                worst_in_margin = margin\r\n                worst_in_dbc = level_dbc\r\n        elif out_band:\r\n            if worst_oob_margin is None or margin < worst_oob_margin:\r\n                worst_oob_margin = margin\r\n                worst_oob_dbc = level_dbc\r\n\r\n    def process_spur(\r\n        spur: MixerWidebandSpurBand,\r\n        mixer_name: str,\r\n        apply_if2_filter: bool,\r\n    ):\r\n        nonlocal results\r\n\r\n        in_band, out_band = classify_spur_band_in_out(spur, rf_inband, oob_range)\r\n        if not in_band and not out_band:\r\n            return\r\n\r\n        lvl_after_dbc, a_if2, a_rf = _integrate_spur_band_through_filters(\r\n            spur, if2_filter, rf_filter, cfg, apply_if2_filter=apply_if2_filter\r\n        )\r\n        level_dbc = lvl_after_dbc\r\n\r\n        f_center = spur.center_freq\r\n        # Scalar limits\r\n        scalar_limit: Optional[dBc] = None\r\n        if in_band and in_band_limit is not None:\r\n            scalar_limit = in_band_limit\r\n        elif out_band and oob_limit is not None:\r\n            scalar_limit = oob_limit\r\n\r\n        # Mask limits\r\n        mask_limit: Optional[dBc] = None\r\n        if mask_cfg is not None:\r\n            if in_band and mask_cfg.apply_in_band:\r\n                if mask_eval_mode == \"center\":\r\n                    mask_limit = interpolate_mask_level_center(f_center)\r\n                else:\r\n                    mask_limit = interpolate_mask_level_worst_case(spur.f_start, spur.f_stop)\r\n            elif out_band and mask_cfg.apply_out_of_band:\r\n                if mask_eval_mode == \"center\":\r\n                    mask_limit = interpolate_mask_level_center(f_center)\r\n                else:\r\n                    mask_limit = interpolate_mask_level_worst_case(spur.f_start, spur.f_stop)\r\n\r\n        effective_limit: Optional[dBc] = None\r\n        # Both scalar limits and mask limits are treated as **hard** limits.\r\n        # Where both exist, the stricter (lower) limit is enforced.\r\n        if scalar_limit is not None and mask_limit is not None:\r\n            effective_limit = min(scalar_limit, mask_limit)\r\n        elif scalar_limit is not None:\r\n            effective_limit = scalar_limit\r\n        elif mask_limit is not None:\r\n            effective_limit = mask_limit\r\n\r\n        scalar_margin = scalar_limit - level_dbc if scalar_limit is not None else None\r\n        mask_margin = mask_limit - level_dbc if mask_limit is not None else None\r\n        margin = effective_limit - level_dbc if effective_limit is not None else None\r\n\r\n        update_worst(level_dbc, in_band, out_band, margin)\r\n\r\n        res = SpurResult(\r\n            config_id=rf_conf.config_id,\r\n            mixer_name=mixer_name,\r\n            spur_name=spur.name,\r\n            f_start=spur.f_start,\r\n            f_stop=spur.f_stop,\r\n            in_band=in_band,\r\n            out_of_band=out_band,\r\n            level_dbc=level_dbc,\r\n            margin_db=margin,\r\n            filter_att_if2_db=a_if2,\r\n            filter_att_rf_db=a_rf,\r\n            origin_m=spur.m,\r\n            origin_n=spur.n,\r\n            lo_tone_name=spur.lo_tone_name,\r\n            input_band_name=spur.input_band_name,\r\n            used_unspecified_floor=spur.used_unspecified_floor,\r\n            scalar_limit_dbc=scalar_limit,\r\n            mask_limit_dbc=mask_limit,\r\n            scalar_margin_db=scalar_margin,\r\n            mask_margin_db=mask_margin,\r\n        )\r\n        results.append(res)\r\n\r\n    # 3a) Mixer1-wideband and other non-desired IF2 content\r\n    #     propagated via Mixer2's desired fundamental path.\r\n    #\r\n    # Any MixerInputBand at IF2 that is *not* the desired IF2 band\r\n    # represents \"junk\" at Mixer2's IF port (cascaded Mixer1 spurs,\r\n    # Mixer1 LO/IF leakage, etc.). When Mixer2 mixes this junk via its\r\n    # fundamental LO2 ± IF2 path, the resulting RF content is a spur\r\n    # and must be checked against RF limits.\r\n    sign2 = lo_plan.sign_combo.sign2\r\n    lo2_freq = lo_plan.lo2_freq\r\n\r\n    for band in m2_input_bands:\r\n        # The desired IF2 band maps to the desired RF channel via the\r\n        # same (m, n) family and should *not* be treated as a spur.\r\n        if band.name == \"IF2_desired_band\":\r\n            continue\r\n\r\n        if2_lo = band.f_start\r\n        if2_hi = band.f_stop\r\n        if if2_hi <= if2_lo:\r\n            continue\r\n\r\n        # Map IF2 band to RF via Mixer2 fundamental\r\n        if sign2 > 0:\r\n            # RF = LO2 + IF2\r\n            rf_start = lo2_freq + if2_lo\r\n            rf_stop = lo2_freq + if2_hi\r\n        else:\r\n            # RF = LO2 - IF2\r\n            rf_start = lo2_freq - if2_hi\r\n            rf_stop = lo2_freq - if2_lo\r\n\r\n        if rf_stop <= rf_start:\r\n            continue\r\n\r\n        rf_center = 0.5 * (rf_start + rf_stop)\r\n\r\n        fund_spur = MixerWidebandSpurBand(\r\n            name=f\"M2_fund_from_{band.name}\",\r\n            mixer_name=cfg.mixer2.name,\r\n            m=cfg.mixer2.desired_m,\r\n            n=cfg.mixer2.desired_n,\r\n            lo_tone_name=\"fundamental\",\r\n            input_band_name=band.name,\r\n            center_freq=rf_center,\r\n            f_start=rf_start,\r\n            f_stop=rf_stop,\r\n            # Level at IF2 after IF2 filter, referenced to IF1 fundamental.\r\n            # Mixer2 fundamental conversion gain is assumed 0 dB in this\r\n            # planning-grade model.\r\n            spur_level_rel_if1_dbc=band.level_dbc_integrated,\r\n            used_unspecified_floor=False,\r\n        )\r\n\r\n        # IF2 filter has already been applied when band.level_dbc_integrated\r\n        # was computed, so we disable IF2 attenuation here and apply only\r\n        # the RF BPF in the integration.\r\n        process_spur(\r\n            fund_spur,\r\n            mixer_name=cfg.mixer2.name,\r\n            apply_if2_filter=False,\r\n        )\r\n\r\n    # 3b) Mixer2 non-desired spur families (from its spur table) reach RF\r\n    #     as wideband products in this model.\r\n    for spur in m2_spurs:\r\n        process_spur(spur, mixer_name=cfg.mixer2.name, apply_if2_filter=False)\r\n\r\n    # 4) Narrowband isolation spurs for Mixer2 (LO->RF, IF->RF)\r\n    def process_narrowband_spur(\r\n        name: str,\r\n        freq: Freq,\r\n        level_before_dbc: dBc,\r\n    ):\r\n        nonlocal results\r\n\r\n        # Attenuation: only RF filter (isolation spur is at Mixer2 RF port)\r\n        a_if2 = 0.0\r\n        a_rf = float(rf_filter.attenuation_db(np.array([freq]))[0])\r\n        level_after = level_before_dbc - a_rf\r\n\r\n        in_band = rf_inband.contains(freq)\r\n        if oob_range is None:\r\n            out_band = not in_band\r\n        else:\r\n            out_band = oob_range.contains(freq) and not in_band\r\n        if not in_band and not out_band:\r\n            return\r\n\r\n        # Limits\r\n        scalar_limit: Optional[dBc] = None\r\n        if in_band and in_band_limit is not None:\r\n            scalar_limit = in_band_limit\r\n        elif out_band and oob_limit is not None:\r\n            scalar_limit = oob_limit\r\n\r\n        mask_limit: Optional[dBc] = None\r\n        if mask_cfg is not None:\r\n            if in_band and mask_cfg.apply_in_band:\r\n                if mask_eval_mode == \"center\":\r\n                    mask_limit = interpolate_mask_level_center(freq)\r\n                else:\r\n                    mask_limit = interpolate_mask_level_worst_case(freq, freq)\r\n            elif out_band and mask_cfg.apply_out_of_band:\r\n                if mask_eval_mode == \"center\":\r\n                    mask_limit = interpolate_mask_level_center(freq)\r\n                else:\r\n                    mask_limit = interpolate_mask_level_worst_case(freq, freq)\r\n\r\n        effective_limit: Optional[dBc] = None\r\n        if scalar_limit is not None and mask_limit is not None:\r\n            effective_limit = min(scalar_limit, mask_limit)\r\n        elif scalar_limit is not None:\r\n            effective_limit = scalar_limit\r\n        elif mask_limit is not None:\r\n            effective_limit = mask_limit\r\n\r\n        scalar_margin = scalar_limit - level_after if scalar_limit is not None else None\r\n        mask_margin = mask_limit - level_after if mask_limit is not None else None\r\n        margin = effective_limit - level_after if effective_limit is not None else None\r\n\r\n        update_worst(level_after, in_band, out_band, margin)\r\n\r\n        res = SpurResult(\r\n            config_id=rf_conf.config_id,\r\n            mixer_name=cfg.mixer2.name,\r\n            spur_name=name,\r\n            f_start=freq,\r\n            f_stop=freq,\r\n            in_band=in_band,\r\n            out_of_band=out_band,\r\n            level_dbc=level_after,\r\n            margin_db=margin,\r\n            filter_att_if2_db=a_if2,\r\n            filter_att_rf_db=a_rf,\r\n            origin_m=0,\r\n            origin_n=0,\r\n            lo_tone_name=name,\r\n            input_band_name=\"isolation\",\r\n            used_unspecified_floor=False,\r\n            scalar_limit_dbc=scalar_limit,\r\n            mask_limit_dbc=mask_limit,\r\n            scalar_margin_db=scalar_margin,\r\n            mask_margin_db=mask_margin,\r\n        )\r\n        results.append(res)\r\n\r\n    # Mixer2 LO->RF isolation for all LO2 tones\r\n    if cfg.mixer2.isolation.lo_to_rf_dbc is not None:\r\n        for tone in m2_lo_tones:\r\n            level_before = cfg.mixer2.isolation.lo_to_rf_dbc + tone.level_dbc\r\n            process_narrowband_spur(\r\n                name=f\"Mixer2_LO_leak_{tone.name}\",\r\n                freq=tone.freq,\r\n                level_before_dbc=level_before,\r\n            )\r\n\r\n    # Mixer2 IF->RF isolation (tone at IF2 band center)\r\n    if cfg.mixer2.isolation.if_to_rf_dbc is not None:\r\n        if2_center = 0.5 * (if2_band.start + if2_band.stop)\r\n        process_narrowband_spur(\r\n            name=\"Mixer2_IF_leak_center\",\r\n            freq=if2_center,\r\n            level_before_dbc=cfg.mixer2.isolation.if_to_rf_dbc,\r\n        )\r\n\r\n    summary = ConfigSpurSummary(\r\n        config_id=rf_conf.config_id,\r\n        worst_in_band_spur_dbc=worst_in_dbc,\r\n        worst_in_band_margin_db=worst_in_margin,\r\n        worst_out_band_spur_dbc=worst_oob_dbc,\r\n        worst_out_band_margin_db=worst_oob_margin,\r\n    )\r\n    return results, summary",
              "encoding": "utf-8",
              "encoding_error": false
            }
          ]
        }
      ]
    },
    {
      "type": "directory",
      "name": "tests",
      "path": "tests",
      "children": []
    },
    {
      "type": "file",
      "name": ".gitignore",
      "path": ".gitignore",
      "size": 119,
      "content_truncated": false,
      "contents": "# Python-generated files\r\n__pycache__/\r\n*.py[oc]\r\nbuild/\r\ndist/\r\nwheels/\r\n*.egg-info\r\n\r\n# Virtual environments\r\n.venv\r\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": ".python-version",
      "path": ".python-version",
      "size": 6,
      "content_truncated": false,
      "contents": "3.13\r\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "pyproject.toml",
      "path": "pyproject.toml",
      "size": 459,
      "content_truncated": false,
      "contents": "[project]\nname = \"bucso3-repo\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \">=3.13\"\ndependencies = [\n    \"matplotlib>=3.10.7\",\n    \"numba>=0.62.1\",\n    \"numpy>=2.3.5\",\n    \"pytest>=9.0.1\",\n    \"pyyaml>=6.0.3\",\n]\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\n\n[build-system]\nrequires = [\"setuptools>=69\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "README.md",
      "path": "README.md",
      "size": 0,
      "content_truncated": false,
      "contents": "",
      "encoding": "utf-8",
      "encoding_error": false
    }
  ]
}